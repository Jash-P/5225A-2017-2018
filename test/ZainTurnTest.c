#pragma config(Sensor, in1,    autoPoti,       sensorPotentiometer)
#pragma config(Sensor, in2,    mobilePoti,     sensorPotentiometer)
#pragma config(Sensor, in3,    liftPoti,       sensorPotentiometer)
#pragma config(Sensor, in4,    armPoti,        sensorPotentiometer)
#pragma config(Sensor, in5,    expander,       sensorAnalog)
#pragma config(Sensor, in6,    lsBarL,         sensorReflection)
#pragma config(Sensor, in7,    lsBarR,         sensorReflection)
#pragma config(Sensor, in8,    gyrorob,        sensorGyro)
#pragma config(Sensor, dgtl1,  trackL,         sensorQuadEncoder)
#pragma config(Sensor, dgtl3,  trackR,         sensorQuadEncoder)
#pragma config(Sensor, dgtl5,  trackB,         sensorQuadEncoder)
#pragma config(Sensor, dgtl7,  sonarL,         sensorSONAR_mm)
#pragma config(Sensor, dgtl9,  limMobile,      sensorTouch)
#pragma config(Sensor, dgtl10, jmpSkills,      sensorDigitalIn)
#pragma config(Sensor, dgtl11, sonarR,         sensorSONAR_mm)
#pragma config(Motor,  port2,           liftL,         tmotorVex393HighSpeed_MC29, openLoop, reversed)
#pragma config(Motor,  port3,           driveL1,       tmotorVex393TurboSpeed_MC29, openLoop, reversed)
#pragma config(Motor,  port4,           driveL2,       tmotorVex393TurboSpeed_MC29, openLoop)
#pragma config(Motor,  port5,           arm,           tmotorVex393HighSpeed_MC29, openLoop, reversed)
#pragma config(Motor,  port6,           mobile,        tmotorVex393HighSpeed_MC29, openLoop)
#pragma config(Motor,  port7,           driveR2,       tmotorVex393TurboSpeed_MC29, openLoop, reversed)
#pragma config(Motor,  port8,           driveR1,       tmotorVex393TurboSpeed_MC29, openLoop)
#pragma config(Motor,  port9,           liftR,         tmotorVex393HighSpeed_MC29, openLoop)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

#define getGyro SensorValue(gyrorob)
#define trackingL SensorValue(trackL)
#define trackingR SensorValue(trackR)
#define BOUND(n, l, h) (((n) < (l))? (l): ((n) > (h))? (h): (n))

bool g_hardStop = false;
float g_turnTarget = 0.0;
bool g_turnEnabled = false;
float g_tolerance = 0.5;
float Kp = 0.5;
int g_turnSpeed = 0;
bool g_anglecorrection = false;

void gyroCalibration()
{
	SensorType[in8] = sensorNone;
	wait1Msec(500);
	//Reconfigure Analog Port 2 as a Gyro sensor and allow time for ROBOTC to calibrate it
	SensorType[in8] = sensorGyro;
	wait1Msec(2000);
	//SensorScale[in8] = 260;
	//SensorFullCount[in8] = 3600;
}

void resetTracking()
{
	trackingL = trackingR = 0;
}
void setLeftDrive(int lspeed)
{
	motor[driveL1] = lspeed;
	motor[driveL2] = lspeed;
}
void setRightDrive(int rspeed)
{
	motor[driveR1] = rspeed;
	motor[driveR2] = rspeed;
}
void setMotorSpeeds(int lspeed, int rspeed)
{
	setLeftDrive(lspeed);
	setRightDrive(rspeed);
}

void simpleStraight(int mspeed, int target)
{
	resetTracking();
	while(trackingL < target)
	{
		setMotorSpeeds(mspeed, mspeed);
	}
}

void straightPID(int target, int mspeed, int motorCorrection)
{
	resetTracking();
	while(trackingL < target)
	{
		if(trackingR < trackingL)
		{
			setRightDrive(mspeed+motorCorrection);
			setLeftDrive(mspeed-motorCorrection);
		}
		if(trackingR > trackingL)
		{
			setRightDrive(mspeed-motorCorrection);
			setLeftDrive(mspeed+motorCorrection);
		}
		if(trackingR == trackingL)
		{
			setRightDrive(mspeed);
			setLeftDrive(mspeed);
		}
	}

}

void gyroPID (int desiredAngle, float motorCorrection, int motorspeed, float ProportionalGain, int gyroValue, int target )
{
	resetTracking();
	wait1Msec(250);
	while(trackingL < target)
	{
		gyroValue = getGyro;
		motorCorrection = ProportionalGain * (gyroValue-desiredAngle);
		setLeftDrive(motorspeed + motorCorrection);
		setRightDrive(motorspeed - motorCorrection);
	}
}
void hardStop()
{
	setRightDrive(+20);
	setLeftDrive(-20);
	sleep(350);
}

void GyroTurnSpeed(int turnSpeed)
{
	g_turnSpeed = turnSpeed;
}
void GyroTurnTargetDegrees(float gyroTarget)
{
	g_turnTarget = gyroTarget;
}
void gyroTurn()
{
	while(getGyro<abs(g_turnTarget*0.5))
	{
		setLeftDrive(g_turnSpeed);
		setRightDrive(-g_turnSpeed);
	}

	while(getGyro<abs(g_turnTarget))
	{
		if((abs(g_turnTarget) - getGyro) < 100)
		{
			hardStop();
			sleep(150);
			break;
		}
		else
		{
		setLeftDrive(28);
		setRightDrive(-28);
		}
	}
}
task EncoderCheck()
{
	while(true)
	{
		if(getGyro!=(trackingL+trackingR/2))
		{
			g_anglecorrection=true;
		}
	}
}
task main()
{
	gyroCalibration();
	GyroTurnSpeed(127);
	GyroTurnTargetDegrees(1800);
	unsigned long time = nPgmTime;
	gyroTurn();
	writeDebugStreamLine("%d", nPgmTime - time);
	//	gyroCalibration();
	//	gyroPID(0,7,40,1.5,0,360);
}
