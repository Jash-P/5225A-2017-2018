#pragma config(Sensor, in1,    leftLight,      sensorReflection)
#pragma config(Sensor, in2,    midLight,       sensorReflection)
#pragma config(Sensor, in3,    rightLight,     sensorReflection)
#pragma config(Sensor, in4,    wristPoti,      sensorPotentiometer)
#pragma config(Sensor, in6,    gyro,           sensorGyro)
#pragma config(Sensor, dgtl1,  rightEnc,       sensorQuadEncoder)
#pragma config(Sensor, dgtl3,  leftEnc,        sensorQuadEncoder)
#pragma config(Sensor, dgtl5,  scissorEnc,     sensorQuadEncoder)
#pragma config(Sensor, dgtl8,  Sonar,          sensorSONAR_cm)
#pragma config(Motor,  port1,           frontRight,    tmotorVex393TurboSpeed_HBridge, openLoop, reversed)
#pragma config(Motor,  port2,           backRight,     tmotorVex393TurboSpeed_MC29, openLoop, reversed)
#pragma config(Motor,  port3,           frontLeft,     tmotorVex393TurboSpeed_MC29, openLoop)
#pragma config(Motor,  port4,           backLeft,      tmotorVex393TurboSpeed_MC29, openLoop)
#pragma config(Motor,  port6,           claw,          tmotorVex393TurboSpeed_MC29, openLoop)
#pragma config(Motor,  port8,           scissorLeft,   tmotorVex393HighSpeed_MC29, openLoop)
#pragma config(Motor,  port9,           scissorRight,  tmotorVex393HighSpeed_MC29, openLoop)
#pragma config(Motor,  port10,          wrist,         tmotorVex393TurboSpeed_HBridge, openLoop)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

#include "Vex_Competition_Includes_Custom.c"

// Library headers
#include "task.h"
#include "async.h"
#include "motors.h"
#include "sensors.h"
#include "joysticks.h"
#include "cycle.h"
#include "utilities.h"
#include "pid.h"
#include "notify.h"

// Library source
#include "task.c"
#include "async.c"
#include "motors.c"
#include "sensors.c"
#include "joysticks.c"
#include "cycle.c"
#include "utilities.c"
#include "pid.c"
#include "notify.c"

// Controls
#include "controls.h"

unsigned long gOverAllTime;
sCycleData gMainCycle;

void setDrive(word left, word right)
{
}

bool gKillDriveOnTimeout = false;

bool TimedOut(unsigned long timeOut, const string description)
{
	if (nPgmTime > timeOut)
	{
		hogCPU();
		// TODO: kill everything except drive
		if (gKillDriveOnTimeout) setDrive(0, 0);
		updateMotors();
		writeDebugStreamLine("%06d EXCEEDED TIME %d - %s", nPgmTime - gOverAllTime, timeOut - gOverAllTime, description);
		int current = nCurrentTask;
		while (true)
		{
			int next = tEls[current].parent;
			if (next == -1 || next == usercontrol) break;
			current = next;
		}
		tStopAll(current);
		return true;
	}
	else
		return false;
}

// Auto
#include "auto.h"
#include "auto_runs.h"

#include "auto.c"
#include "auto_runs.c"

//void moveToTarget(float y, float x, byte power, float delta, float lineEpsilon = 1, float targetEpsilon = 1.5, bool harshStop = true, bool slow = true);
//void moveToTarget(float y, float x, float ys, float xs, byte power, float delta, float lineEpsilon = 1, float targetEpsilon = 1.5, bool harshStop = true, bool slow = true);
////////////

int lightVal;
int lightThresh;
int lightMin = 2000;
int lightMax = 0;
int scissorBottom = -180;
int scissorTop = 1400;

/////////////////// cycle test. delete after

void setDrive (int left, int right)
{
	motor [frontRight] = motor [backRight] = right;
	motor [frontLeft] = motor [backLeft] = left;
}

void setArm (int speed, int distance)
{
	motor [scissorLeft] = motor [scissorRight] = speed;
	if (speed > 0)
	{
		while (SensorValue [scissorEnc] < distance) sleep(10);
	}
	else if (speed < 0)
	{
		while (SensorValue [scissorEnc] < distance) sleep(10);
	}

}

void closeClaw (bool state)
{
	if (state == true) motor [claw] = 127;
	else if (state == false) motor [claw] = -127;
	unsigned long startTimer = nPgmTime;
	while (nPgmTime-startTimer < 200) sleep (10);
	motor [claw] = 0;
}

void calibrate ()
{
	sCycleData cycle;
	initCycle(cycle, 10, "calibrate");

	setDrive (127, 127);
	while (SensorValue[leftEnc] < 700)
	{
		lightVal = SensorValue[midLight];
		if (lightVal < lightMin) lightMin = lightVal;
		if (lightVal > lightMax) lightMax = lightVal;
	}
	lightThresh = (lightMax + lightMin) / 2;
	setDrive (0, 0);

	endCycle(cycle);
} // if sensorVal<1000, should be a white line

// This function gets called 2 seconds after power on of the cortex and is the first bit of code that is run
void startup()
{
	clearDebugStream();
	writeDebugStreamLine("Code start");

	// Setup and initilize the necessary libraries
	setupMotors();
	setupSensors();
	setupJoysticks();
	tInit();

	gJoy[JOY_TURN].deadzone = DZ_TURN;
	gJoy[JOY_THROTTLE].deadzone = DZ_THROTTLE;
	gJoy[JOY_LIFT].deadzone = DZ_LIFT;
	gJoy[JOY_ARM].deadzone = DZ_ARM;
}

// This function gets called every 25ms during disabled (DO NOT PUT BLOCKING CODE IN HERE)
void disabled()
{
}

// This task gets started at the begining of the autonomous period
task autonomous()
{
	gAutoTime = nPgmTime;
	writeDebugStreamLine("Auto start %d", gAutoTime);

	startSensors(); // Initilize the sensors

	gKillDriveOnTimeout = true;

	resetPosition(gPosition);
	//resetQuadratureEncoder(driveEncL);
	//resetQuadratureEncoder(driveEncR);
	//resetQuadratureEncoder(latEnc);

	tStart(autoMotorSensorUpdateTask);
	tStart(trackPositionTask);

	runAuto();

	writeDebugStreamLine("Auto: %d ms", nPgmTime - gAutoTime);

	return_t;
}

task usercontrol()
{
	startSensors(); // Initilize the sensors
	initCycle(gMainCycle, 20, "main");

	gKillDriveOnTimeout = false;

	while (true)
	{
		updateSensorInputs();
		updateJoysticks();

		// TODO: put your main drive code here

		updateSensorOutputs();
		updateMotors();
		endCycle(gMainCycle);
	}

	return_t;
}
