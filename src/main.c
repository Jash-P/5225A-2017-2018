#pragma config(Sensor, in1,    autoPoti,       sensorPotentiometer)
#pragma config(Sensor, in2,    mobilePoti,     sensorPotentiometer)
#pragma config(Sensor, in4,    liftPoti,       sensorPotentiometer)
#pragma config(Sensor, in5,    armPoti,        sensorPotentiometer)
#pragma config(Sensor, dgtl1,  limBottom,      sensorTouch)
#pragma config(Sensor, dgtl2,  limTop,         sensorTouch)
#pragma config(Sensor, dgtl3,  driveEncL,      sensorQuadEncoder)
#pragma config(Sensor, dgtl5,  driveEncR,      sensorQuadEncoder)
#pragma config(Sensor, dgtl7,  latEnc,         sensorQuadEncoder)
#pragma config(Sensor, dgtl9,  armSonic,       sensorSONAR_mm)
#pragma config(Motor,  port1,           liftL,         tmotorVex393_HBridge, openLoop, reversed)
#pragma config(Motor,  port2,           arm,           tmotorVex393HighSpeed_MC29, openLoop, reversed)
#pragma config(Motor,  port3,           driveL2,       tmotorVex393_MC29, openLoop, reversed)
#pragma config(Motor,  port4,           driveL1,       tmotorVex393TurboSpeed_MC29, openLoop)
#pragma config(Motor,  port5,           mobileL,       tmotorVex393TurboSpeed_MC29, openLoop)
#pragma config(Motor,  port6,           mobileR,       tmotorVex393TurboSpeed_MC29, openLoop, reversed)
#pragma config(Motor,  port7,           driveR1,       tmotorVex393TurboSpeed_MC29, openLoop, reversed)
#pragma config(Motor,  port8,           driveR2,       tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port9,           intake,        tmotorVex269_MC29, openLoop, reversed)
#pragma config(Motor,  port10,          liftR,         tmotorVex393HighSpeed_HBridge, openLoop)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

#include "Vex_Competition_Includes_Custom.c"

#include "motors.h"
#include "sensors.h"
#include "joysticks.h"
#include "cycle.h"
#include "utilities.h"

#include "motors.c"
#include "sensors.c"
#include "joysticks.c"
#include "cycle.c"
#include "utilities.c"


sCycleData gMainCycle;

/* Drive */
#define TCHN Ch4
#define PCHN Ch3
#define LCHN Ch2
#define ACHN Ch1

#define TDZ 10
#define PDZ 10
#define LDZ 25
#define ADZ 25

void setDrive(word left, word right)
{
	gMotor[driveL1].power = gMotor[driveL2].power = left;
	gMotor[driveR1].power = gMotor[driveR2].power = right;
}

void handleDrive()
{
	setDrive(gJoy[PCHN].cur + gJoy[TCHN].cur, gJoy[PCHN].cur - gJoy[TCHN].cur);
}


/* Lift */
typedef enum _sLiftStates {
	liftIdle,
	liftRaise,
	liftLower,
	liftRaiseBrk,
	liftLowerBrk,
	liftHold,
	liftAuto
} sLiftStates;

#define LIFT_UP_KP 2
#define LIFT_DOWN_KP 1.5

#define LIFT_BOTTOM 110
#define LIFT_TOP 4094

short gLiftTarget;
sLiftStates gLiftState = liftIdle;

void setLift(word power)
{
	gMotor[liftL].power = gMotor[liftR].power = power;
}

void handleLift()
{
	if (RISING(Btn5U))
	{
		gLiftTarget = LIFT_TOP;
		gLiftState = liftRaise;
	}
	else if (FALLING(Btn5U))
	{
		gLiftTarget = gSensor[liftPoti].value;
	}
	if (RISING(Btn5D))
	{
		gLiftTarget = LIFT_BOTTOM;
		gLiftState = liftLower;
	}

	switch (gLiftState)
	{
		case liftRaise:
		{
			short error = gLiftTarget - gSensor[liftPoti].value;
			if (error <= 0 || gSensor[limTop].value)
			{
				velocityClear(liftPoti);
				setLift(-10);
				gLiftState = liftRaiseBrk;
			}
			else
			{
				float output = error * LIFT_UP_KP;
				if (output < 60) output = 60;
				setLift((word)output);
			}
			break;
		}
		case liftRaiseBrk:
		{
			velocityCheck(liftPoti);
			if (gSensor[liftPoti].velGood && gSensor[liftPoti].velocity <= 0) gLiftState = liftHold;
			break;
		}
		case liftLower:
		{
			short error = gLiftTarget - gSensor[liftPoti].value;
			if (error >= 0 || gSensor[limBottom].value)
			{
				velocityClear(liftPoti);
				setLift(10);
				gLiftState = liftLowerBrk;
			}
			else
			{
				float output = error * LIFT_DOWN_KP;
				if (output > -60) output = -60;
				setLift((word)output);
			}
			break;
		}
		case liftLowerBrk:
		{
			velocityCheck(liftPoti);
			if (gSensor[liftPoti].velGood && gSensor[liftPoti].velocity >= 0) gLiftState = liftHold;
			break;
		}
		case liftHold:
		{
			if (!gSensor[limBottom].value)
				setLift(12);
			else
				setLift(0);
			break;
		}
	}
}


/* Arm */
typedef enum _sArmStates {
	armIdle,
	armRaise,
	armLower,
	armRaiseBrk,
	armLowerBrk,
	armHold,
	armAuto
} sArmStates;

#define ARM_UP_KP 0.15
#define ARM_DOWN_KP 0.08
#define ARM_POSITIONS (ARR_LEN(gArmPositions) - 1)

short gArmPositions[] = { 950, 1650, 2400 };
short gArmPosition = 0;
short gArmTarget;
sArmStates gArmState = armIdle;

void setArm(word power)
{
	if (power != gMotor[arm].power) writeDebugStreamLine("%d %d", gMainCycle.count, power);
	gMotor[arm].power = power;
}

void handleArm()
{
	if (RISING(Btn6U))
	{
		if (gArmPosition < ARM_POSITIONS)
		{
			gArmTarget = gArmPositions[++gArmPosition];
			gArmState = armRaise;
		}
	}
	if (RISING(Btn6D))
	{
		if (gArmPosition > 0)
		{
			gArmTarget = gArmPositions[--gArmPosition];
			gArmState = armLower;
		}
	}

	switch (gArmState)
	{
		case armRaise:
		{
			short error = gArmTarget - gSensor[armPoti].value;
			if (error <= 100)
			{
				velocityClear(armPoti);
				setArm(-8);
				gArmState = armRaiseBrk;
			}
			else
			{
				float output = error * ARM_UP_KP;
				if (output < 50) output = 50;
				setArm((word)output);
			}
			break;
		}
		case armRaiseBrk:
		{
			velocityCheck(armPoti);
			if (gSensor[armPoti].velGood && gSensor[armPoti].velocity <= 0) gArmState = armHold;
			break;
		}
		case armLower:
		{
			short error = gArmTarget - gSensor[armPoti].value;
			if (error >= -100)
			{
				velocityClear(armPoti);
				setArm(15);
				gArmState = armLowerBrk;
			}
			else
			{
				float output = error * ARM_DOWN_KP;
				if (output > -30) output = -30;
				setArm((word)output);
			}
			break;
		}
		case armLowerBrk:
		{
			velocityCheck(armPoti);
			if (gSensor[armPoti].velGood && gSensor[armPoti].velocity >= 0) gArmState = armHold;
			break;
		}
		case armHold:
		{
			if (gArmPosition == ARM_POSITIONS)
				setArm(10);
			else
				setArm(12);
			break;
		}
	}
}


/* Intake */

void setIntake(word power)
{
	gMotor[intake].power = power;
}

void handleIntake()
{
	if (gJoy[Btn7U].cur) setIntake(127);
	else if (gJoy[Btn7D].cur) setIntake(-127);
	else setIntake(0);
}


/* Mobile Goal */

#define MOBILE_TOP 2610
#define MOBILE_BOTTOM 1100

#define MOBILE_UP_POWER 127
#define MOBILE_DOWN_POWER -127
#define MOBILE_UP_HOLD_POWER 6
#define MOBILE_DOWN_HOLD_POWER -6

void setMobile(word power)
{
	gMotor[mobileL].power = gMotor[mobileR].power = power;
}

void handleMobile()
{
	if (RISING(Btn8U)) setMobile(MOBILE_UP_POWER);
	else if (RISING(Btn8D)) setMobile(MOBILE_DOWN_POWER);

	if (gMotor[mobileL].power == MOBILE_UP_POWER && gSensor[mobilePoti].value >= MOBILE_TOP) setMobile(MOBILE_UP_HOLD_POWER);
	if (gMotor[mobileL].power == MOBILE_DOWN_POWER && gSensor[mobilePoti].value <= MOBILE_BOTTOM) setMobile(MOBILE_DOWN_HOLD_POWER);
}


// This function gets called 2 seconds after power on of the cortex and is the first bit of code that is run
void startup()
{
	// Setup and initilize the necessary libraries
	setupMotors();
	setupSensors();
	setupJoysticks();

	gJoy[TCHN].deadzone = TDZ;
	gJoy[PCHN].deadzone = PDZ;
	gJoy[LCHN].deadzone = LDZ;
	gJoy[ACHN].deadzone = ADZ;
}

// This function gets called every 25ms during disabled (DO NOT PUT BLOCKING CODE IN HERE)
void disabled()
{

}

// This task gets started at the begining of the autonomous period
task autonomous()
{
	startSensors(); // Initilize the sensors
}

// This task gets started at the beginning of the usercontrol period
task usercontrol()
{
	startSensors(); // Initilize the sensors
	initCycle(gMainCycle, 10);

	while (true)
	{
		updateSensorInputs();
		updateJoysticks();

		handleDrive();
		handleLift();
		handleArm();
		handleIntake();
		handleMobile();

		updateSensorOutputs();
		updateMotors();
		endCycle(gMainCycle);
	}
}
