#pragma config(Sensor, in1,    autoPoti,       sensorPotentiometer)
#pragma config(Sensor, in2,    mobilePoti,     sensorPotentiometer)
#pragma config(Sensor, in3,    liftPoti,       sensorPotentiometer)
#pragma config(Sensor, in4,    armPoti,        sensorPotentiometer)
#pragma config(Sensor, in5,    limLift,         sensorAnalog)
#pragma config(Sensor, in6,    lsBarL,         sensorReflection)
#pragma config(Sensor, in7,    lsBarR,         sensorReflection)
#pragma config(Sensor, in8,    lsMobile,       sensorReflection)
#pragma config(Sensor, dgtl1,  trackL,         sensorQuadEncoder)
#pragma config(Sensor, dgtl3,  trackR,         sensorQuadEncoder)
#pragma config(Sensor, dgtl5,  trackB,         sensorQuadEncoder)
#pragma config(Sensor, dgtl7,  sonarL,         sensorSONAR_mm)
#pragma config(Sensor, dgtl9,  limArm,         sensorTouch)
#pragma config(Sensor, dgtl10, jmpSkills,      sensorDigitalIn)
#pragma config(Sensor, dgtl11, sonarR,         sensorSONAR_mm)
#pragma config(Motor,  port2,           liftR,         tmotorVex393HighSpeed_MC29, openLoop)
#pragma config(Motor,  port3,           driveL1,       tmotorVex393TurboSpeed_MC29, openLoop, reversed)
#pragma config(Motor,  port4,           driveL2,       tmotorVex393TurboSpeed_MC29, openLoop)
#pragma config(Motor,  port5,           arm,           tmotorVex393HighSpeed_MC29, openLoop, reversed)
#pragma config(Motor,  port6,           mobile,        tmotorVex393HighSpeed_MC29, openLoop)
#pragma config(Motor,  port7,           driveR2,       tmotorVex393TurboSpeed_MC29, openLoop, reversed)
#pragma config(Motor,  port8,           driveR1,       tmotorVex393TurboSpeed_MC29, openLoop)
#pragma config(Motor,  port9,           liftL,         tmotorVex393HighSpeed_MC29, openLoop, reversed)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

#define LOGS 1
//#define log(msg) (#ifdef LOGS writeDebugStreamLine(msg))
#define CHECK_POTI_JUMPS 1
#define DRIVE_TURN (gJoy[JOY_TURN].cur - gJoy[JOY_TURN].deadzone * sgn(gJoy[JOY_TURN].cur))

// Year-independent libraries (headers)
#include "task.h"
#include "motors.h"
#include "sensors.h"
#include "joysticks.h"
#include "cycle.h"
#include "utilities.h"

// Year-independent libraries (source)
#include "task.c"
#include "motors.c"
#include "sensors.c"
#include "joysticks.c"
#include "cycle.c"
#include "utilities.c"

// Other includes
#include "Vex_Competition_Includes_Custom.c"

#include "state.h"
#include "controls.h"

/* Drive Controls */
void handleDrive()
{
	gMotor[driveL1].power = gMotor[driveL2].power = LIM_TO_VAL((gJoy[JOY_THROTTLE].cur + DRIVE_TURN), 127);
	gMotor[driveR1].power = gMotor[driveR2].power = LIM_TO_VAL((gJoy[JOY_THROTTLE].cur - DRIVE_TURN), 127);

	if (!gJoy[JOY_THROTTLE}.cur && !gJoy[JOY_TURN].cur )
{
	velocityCheck(trackL);
	velocityCheck(trackR);
	//writeDebugStreamLine("L: %d, r: %d", gSensor[trackL].velocity, gSensor[trackR].velocity);
	if (gSensor[trackL].velGood && gSensor[trackL].velGood)
	{
		if (gSensor[trackL].velocity > 0.3)
			gMotor[driveL1].power = gMotor[driveL2].power  = LIM_TO_VAL(sgn(gSensor[trackL].velocity) * -8, 15);
		if (gSensor[trackR].velocity > 0.3)
			gMotor[driveR1].power = gMotor[driveR2].power  = LIM_TO_VAL(sgn(gSensor[trackR].velocity) * -8, 15);
	}
}
}

/* Lift Controls */
#define LIFT_BOTTOM 800 //1100
#define LIFT_TOP (LIFT_BOTTOM + 1930)
#define LIFT_MID (LIFT_BOTTOM + 620)
#define LIFT_HOLD_DOWN_THRESHOLD (LIFT_BOTTOM + 50)
#define LIFT_HOLD_UP_THRESHOLD (LIFT_TOP - 100)

void setLift(word val)
{
gMotor[liftR].power = gMotor[liftL].power = LIM_TO_VAL(val, 127);
}

CREATE_MACHINE(lift, Idle, Hold, Manual, Move, MoveSimple, int, Target, int, Power)
{
	sCycleData lift;
	initCycle(lift, 10, "lift");
	while (true)
	{
		switch (liftState)
		{
		case 0: //idle
			{
				setLift(0);
				break;
			}
		case 1: //hold
			{
				if (gSensor[liftPoti].value < LIFT_HOLD_DOWN_THRESHOLD) //Lift is at bottom
					setLift(!gSensor[limLift].value ? -15 : -90);
				else if (gSensor[liftPoti].value > LIFT_HOLD_UP_THRESHOLD) //Lift is at top
					setLift(gSensor[liftPoti].value >= LIFT_TOP ? 15 : 127);
				else //Lift is in middle
					setLift(gSensor[liftPoti].value > LIFT_MID ? 12 : 10);
				break;
			}
		case 2: //manual
			{
				short joy = gJoy[JOY_LIFT].cur;
				setLift(joy);

				velocityCheck(liftPoti);
				if(gSensor[liftPoti].velGood)
					writeDebugStreamLine("power:%d, vel: %f", joy, gSensor[liftPoti].velocity);

				if ((sgn(joy) == -1 && gSensor[liftPoti].value < LIFT_HOLD_DOWN_THRESHOLD) || (sgn(joy) == 1 && gSensor[liftPoti].value > LIFT_HOLD_UP_THRESHOLD))
					liftStateChange(liftHold);
				break;
			}
		case 3: //move
			{
				if (liftTarget == -1)
			{
				liftStateChange(liftHold);
			}
			else
			{
				int dir = (liftTarget < gSensor[liftPoti].value)? -1 : 1;
				//abs velocity of arm is 0.3-2.5
				int firstTarg = liftTarget + (dir == 1? -150 : 150);
				float pB = (dir == 1)? 25 : 30; //base power
				float vKP = 0.006; //kP for targVel
				float pKP = 30.0; //kP for power
				float targVel, power;

				while ( (dir == 1)? (gSensor[liftPoti].value < firstTarg) : (gSensor[liftPoti].value > firstTarg) )
				{
					targVel = vKP * (liftTarget - gSensor[liftPoti].value);
					velocityCheck(liftPoti);
					if (gSensor[liftPoti].velGood)
					{
						power = LIM_TO_VAL( (pB + (pKP * (targVel - gSensor[liftPoti].velocity))), 127);

						if (abs(gSensor[liftPoti].velocity) < 1.0) // if stalled, apply enough power to move
						{
							if (dir == 1 && power < 27)
								power = 27;
							else if (dir == -1 && power > -27)
								power = -27;
						}

						if ( sgn(power) != sgn(dir) )
							LIM_TO_VAL_SET(power, 5);

						writeDebugStreamLine("Power: %d in dir: %d. vel:%f, velTarg:%f, Loc: %d, Targ: %d", power, dir, gSensor[liftPoti].velocity, targVel, gSensor[liftPoti].value, firstTarg);
						setLift(power);
					}
					sleep(10);
				}

				setLift(0);
				writeDebugStreamLine("targ: %d", liftTarget);
				velocityCheck(liftPoti);
				if (gSensor[liftPoti].velGood)
				{
					while ( abs(gSensor[liftPoti].velocity) > 0.75  && ( (dir == 1)? (gSensor[liftPoti].value < liftTarget) : (gSensor[liftPoti].value > liftTarget) ) )
					{
						velocityCheck(liftPoti);
						writeDebugStreamLine("loc: %d, abs-vel: %f", gSensor[liftPoti].value, abs(gSensor[liftPoti].velocity));
						//writeDebugStreamLine("Power: 0 in dir: %d. Loc: %d, Targ: %d", gMotor[arm].power , dir, gSensor[armPoti].value, gArmTarget);
						sleep(10);
					}
				}
				liftStateChange(liftHold);
			}
				break;
			}
		}
		endCycle(lift);
	}
}


void handleLift() //Decide which state to put machine in
{
	//writeDebugStreamLine("State = %d, Lift loc = %d, Lift Power = %d", liftState, gSensor[liftPoti].value, gMotor[liftR].power);

	short joy = gJoy[JOY_LIFT].cur;
	if (RISING(JOY_LIFT) && liftState != liftManual)
		{
			liftStateChange(liftManual);
		}
	else if (!joy && liftState == liftManual)//|| abs(gJoy[JOY_ARM].cur) < abs(gJoy[JOY_ARM].lst))
		{
			liftStateChange(liftHold);
		}
	if (RISING(BTN_LIFT_TEST) && liftState != liftMove)
	{
		liftStateChange(liftMove, 1200, LIFT_MID+300, -1);
		//LIFT_STATE(move, LIFT_MID+300, -1);
	}
}


/* Arm Controls */
#define RL_ARM_TOP 2700
#define ARM_TOP (RL_ARM_TOP - 100)

//Actual ARM_BOTTOM = 1020
#define ARM_BOTTOM (RL_ARM_TOP - 1450)

#define ARM_PRESTACK (RL_ARM_TOP - 800)
#define ARM_RELEASE (RL_ARM_TOP - 700)
#define ARM_CARRY (RL_ARM_TOP - 1040)
#define ARM_STACK (RL_ARM_TOP - 100)
//#define ARM_HORIZONTAL (RL_ARM_TOP - 1590)
#define ARM_HOLD_DOWN_THRESHOLD (ARM_BOTTOM + 50)

void setArm(word val)
{
gMotor[arm].power = LIM_TO_VAL(val, 127);
}

typedef enum _tArmStates
{
idle,
hold,
manual,
move,
moveSimple
} tArmStates;

tArmStates gArmState = idle;
int gArmTarget;
int gArmPower

#define ARM_STATE(state, target, power) gArmState = state; \
gArmTarget = target; \
gArmPower = power; \
writeDebugStreamLine ("%d Arm State:%d, loc: %d, %d, %d, %d", npgmTime, gArmState, gSensor[armPoti].value, gArmTarget, gArmPower);

task setArmState()
{
sCycleData arm;
initCycle(arm, 10, "arm");
while(true)
{
	//writeDebugStreamLine("Arm Task");
	switch (gArmState)
	{
	case 0: //idle
		{
			setArm(0);
			break;
		}
	case 1: //hold
		{
			if (gSensor[armPoti].value < ARM_HOLD_DOWN_THRESHOLD) //Arm is at bottom
				setArm(gSensor[limArm].value ? -15 : -40);
			else
				setArm(7);
			break;
		}
	case 2: //manual
		{
			short joy = -1 * (gJoy[JOY_ARM].cur);
			velocityCheck(armPoti);
			if (gSensor[armPoti].velGood)
				writeDebugStreamLine("power: %d, vel: %f", joy, gSensor[armPoti].velocity);

			setArm(joy);

			if (	(sgn(joy) == -1 && gSensor[armPoti].value < (ARM_BOTTOM + 20)) || (sgn(joy) == 1 && gSensor[armPoti].value > (ARM_TOP - 20)) )
				ARM_STATE(hold, -1, -1);

			break;
		}
	case 3: //move
		{
			if (gArmTarget == -1)
			{
				ARM_STATE(hold, -1, -1);
			}
			else
			{
				int dir = (gArmTarget < gSensor[armPoti].value)? -1 : 1;
				//abs velocity of arm is 0.7-4.0
				int firstTarg = gArmTarget + (dir == 1? -50 : 200);
				float pB = (dir == 1)? 25 : 0; //base power
				float vKP = 0.006; //kP for targVel
				float pKP = 30.0; //kP for power
				float targVel, power;

				while ( (dir == 1)? (gSensor[armPoti].value < firstTarg) : (gSensor[armPoti].value > firstTarg) )
				{
					targVel = vKP * (gArmTarget - gSensor[armPoti].value);
					velocityCheck(armPoti);
					if (gSensor[armPoti].velGood)
					{
						power = LIM_TO_VAL( (pB + (pKP * (targVel - gSensor[armPoti].velocity))), 127);

						if (abs(gSensor[armPoti].velocity) < 2.6) // if stalled, apply enough power to move
						{
							if (dir == 1 && power < 26)
								power = 26;
							else if (dir == -1 && power > -7)
								power = -7;
						}

						if ( sgn(power) != sgn(dir) )
							LIM_TO_VAL_SET(power, (dir == 1)? 4 : 8);

						writeDebugStreamLine("Power: %d in dir: %d. vel:%f, velTarg:%f, Loc: %d, Targ: %d", power, dir, gSensor[armPoti].velocity, targVel, gSensor[armPoti].value, firstTarg);
						setArm(power);
					}
					sleep(10);
				}

				setArm(0);
				writeDebugStreamLine("targ: %d", gArmTarget);
				velocityCheck(armPoti);
				if (gSensor[armPoti].velGood)
				{
					while ( abs(gSensor[armPoti].velocity) > 0.75  && ( (dir == 1)? (gSensor[armPoti].value < gArmTarget) : (gSensor[armPoti].value > gArmTarget) ) )
					{
						velocityCheck(armPoti);
						writeDebugStreamLine("loc: %d, abs-vel: %f", gSensor[armPoti].value, abs(gSensor[armPoti].velocity));
						//writeDebugStreamLine("Power: 0 in dir: %d. Loc: %d, Targ: %d", gMotor[arm].power , dir, gSensor[armPoti].value, gArmTarget);
						sleep(10);
					}
				}
				ARM_STATE(hold, -1, -1);
			}
			break;
		}
	case 4: //moveSimple
		{
			if (gArmTarget == -1)
			{
				ARM_STATE(hold, -1, -1);
			}
			else
			{
				int dir = (gArmTarget < gSensor[armPoti].value)? -1 : 1;

				gArmPower = abs(gArmPower) * dir;
				writeDebugStreamLine ("move: set power %d, dir %d, poti %d", gArmPower, dir, gSensor[armPoti].value);
				setArm(gArmPower);
				while ( (dir == 1)? (gSensor[armPoti].value < gArmTarget) : (gSensor[armPoti].value > gArmTarget) )
					sleep(10);
			}
			break;
		}
	}
	endCycle(arm);
}
}


void handleArm() //Decide which state to put machine in
{
short joy = gJoy[JOY_ARM].cur;
if (RISING(JOY_ARM) && gArmState != manual)
{
	ARM_STATE(manual, -1, -1);
}
else if (!joy && gArmState == manual)//|| abs(gJoy[JOY_ARM].cur) < abs(gJoy[JOY_ARM].lst))
{
	ARM_STATE(hold, -1, -1);
}

if (RISING(BTN_STACK) && gArmState != move)
{
	writeDebugStreamLine("Stack button");
	ARM_STATE(move, ARM_TOP - 800, 80);
}
}

/* Mobile Goal Controls */
#define MOBILE_TOP 2430
#define MOBILE_BOTTOM 900
#define MOBILE_MIDDLE_UP 1150
#define MOBILE_MIDDLE_DOWN 1650
#define MOBILE_MIDDLE_THRESHOLD 2250
#define MOBILE_HALFWAY 1550

#define MOBILE_UP_HOLD_POWER 12
#define MOBILE_DOWN_HOLD_POWER -15

typedef enum _tMobileStates
{
idle,
hold,
moveTop,
moveBottom,
moveUpToMid,
moveDownToMid,
holdMid
}tMobileStates;

tMobileStates gMobileState = idle;

void setMobile(word val)
{
gMotor[mobile].power = val;
}

task setMobileState()
{
sCycleData mobile;
initCycle(mobile, 10, "mobile");
while (true)
{
	switch (gMobileState)
	{
	case 0: //idle
		{
			setMobile(0);
			break;
		}
	case 1: //hold
		{
			setMobile(gSensor[mobilePoti].value < MOBILE_HALFWAY? -5 : 5);
			break;
		}
	case 2: //moveTop
		{
			setMobile(127);
			if (gSensor[mobilePoti].value > (MOBILE_TOP - 50))
				gMobileState = hold;
			break;
		}
	case 3: //moveBottom
		{
			setMobile(-127);
			if (gSensor[mobilePoti].value < (MOBILE_BOTTOM + 50))
				gMobileState = hold;
			break;
		}
	case 4: //moveUpToMid
		{
			setMobile(127);
			if (gSensor[mobilePoti].value > MOBILE_MIDDLE_UP)
				gMobileState = holdMid;
			break;
		}
	case 5: //moveDownToMid
		{
			setMobile(-127);
			if (gSensor[mobilePoti].value < MOBILE_MIDDLE_DOWN)
				gMobileState = holdMid;
			break;
		}
	case 6: //holdMid
		{
			if (gSensor[mobilePoti].value > MOBILE_MIDDLE_DOWN-100)
				setMobile(0);
			else
				setMobile(15);
			break;
		}
	}
	endCycle(mobile);
}
}

void handleMobile()
{
if (RISING(BTN_MOBILE_TOGGLE))
{
	writeDebugStreamLine("Toggle Mobile");
	if (gMobileState != holdMid)
	{
		gMobileState = (gSensor[mobilePoti].value < MOBILE_HALFWAY)? moveTop : moveBottom;
		writeDebugStreamLine("Mobile state: %d", gMobileState);
	}
	else
	{
		gMobileState = moveTop;
	}
}
if (RISING(BTN_MOBILE_MIDDLE))
{
	if (gMobileState != holdMid)
		gMobileState = (gSensor[mobilePoti].value < MOBILE_HALFWAY)? moveUpToMid : moveDownToMid;
	else
		gMobileState = moveBottom;
}
}

void startup()
{
clearDebugStream();
setupSensors();
setupMotors();
setupJoysticks();
tInit();

//Setup Joysticks & Buttons
enableJoystick(JOY_THROTTLE);
enableJoystick(JOY_TURN);
enableJoystick(JOY_LIFT);
enableJoystick(JOY_ARM);
enableJoystick(BTN_MOBILE_TOGGLE);
enableJoystick(BTN_MOBILE_MIDDLE);
enableJoystick(BTN_STACK);
enableJoystick(BTN_LIFT_TEST);

gJoy[JOY_THROTTLE].deadzone = 15;
gJoy[JOY_TURN].deadzone = 15;
gJoy[JOY_LIFT].deadzone = 25;
gJoy[JOY_ARM].deadzone = 25;
}

void disabled()
{
updateSensorInputs();
//selectAuto();
//handleLcd();
}

task autonomous()
{
sCycleData cycle;
initCycle(cycle, 10, "autonomous");

while(true)
{
	endCycle(cycle);
}
}

task usercontrol()
{
sCycleData cycle;
initCycle(cycle, 10, "usercontrol");

tStart(liftSet);
tStart(setArmState);
tStart(setMobileState);

while (true)
{
	updateJoysticks();
	updateMotors();
	updateSensorInputs();
	updateSensorOutputs();

	handleDrive();
	handleLift();
	handleArm();
	handleMobile();

	//setMobileState();

	endCycle(cycle);
}
tStop(liftSet);
tStop(setArmState);
tStop(setMobileState);
}
