#pragma config(Sensor, in1,    autoPoti,       sensorPotentiometer)
#pragma config(Sensor, in2,    mobilePoti,     sensorPotentiometer)
#pragma config(Sensor, in3,    liftPoti,       sensorPotentiometer)
#pragma config(Sensor, in4,    armPoti,        sensorPotentiometer)
#pragma config(Sensor, in5,    limLift,         sensorAnalog)
#pragma config(Sensor, in6,    lsBarL,         sensorReflection)
#pragma config(Sensor, in7,    lsBarR,         sensorReflection)
#pragma config(Sensor, in8,    lsMobile,       sensorReflection)
#pragma config(Sensor, dgtl1,  trackL,         sensorQuadEncoder)
#pragma config(Sensor, dgtl3,  trackR,         sensorQuadEncoder)
#pragma config(Sensor, dgtl5,  trackB,         sensorQuadEncoder)
#pragma config(Sensor, dgtl7,  sonarL,         sensorSONAR_mm)
#pragma config(Sensor, dgtl9,  limArm,         sensorTouch)
#pragma config(Sensor, dgtl10, jmpSkills,      sensorDigitalIn)
#pragma config(Sensor, dgtl11, sonarR,         sensorSONAR_mm)
#pragma config(Motor,  port2,           liftR,         tmotorVex393HighSpeed_MC29, openLoop)
#pragma config(Motor,  port3,           driveL1,       tmotorVex393TurboSpeed_MC29, openLoop, reversed)
#pragma config(Motor,  port4,           driveL2,       tmotorVex393TurboSpeed_MC29, openLoop)
#pragma config(Motor,  port5,           arm,           tmotorVex393HighSpeed_MC29, openLoop, reversed)
#pragma config(Motor,  port6,           mobile,        tmotorVex393HighSpeed_MC29, openLoop)
#pragma config(Motor,  port7,           driveR2,       tmotorVex393TurboSpeed_MC29, openLoop, reversed)
#pragma config(Motor,  port8,           driveR1,       tmotorVex393TurboSpeed_MC29, openLoop)
#pragma config(Motor,  port9,           liftL,         tmotorVex393HighSpeed_MC29, openLoop, reversed)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

#define CHECK_POTI_JUMPS 1
#define DRIVE_TURN (gJoy[JOY_TURN].cur - gJoy[JOY_TURN].deadzone * sgn(gJoy[JOY_TURN].cur))

// Year-independent libraries (headers)
#include "task.h"
#include "motors.h"
#include "sensors.h"
#include "joysticks.h"
#include "cycle.h"
#include "utilities.h"

// Year-independent libraries (source)
#include "task.c"
#include "motors.c"
#include "sensors.c"
#include "joysticks.c"
#include "cycle.c"
#include "utilities.c"

// Other includes
#include "Vex_Competition_Includes_Custom.c"

#include "controls.h"

/* Drive Controls */
void handleDrive()
{
	gMotor[driveL1].power = gMotor[driveL2].power = LIM_TO_VAL((gJoy[JOY_THROTTLE].cur + DRIVE_TURN), 127);
	gMotor[driveR1].power = gMotor[driveR2].power = LIM_TO_VAL((gJoy[JOY_THROTTLE].cur - DRIVE_TURN), 127);

	if (!gJoy[JOY_THROTTLE}.cur && !gJoy[JOY_TURN].cur )
{
	velocityCheck(trackL);
	velocityCheck(trackR);
	//writeDebugStreamLine("L: %d, r: %d", gSensor[trackL].velocity, gSensor[trackR].velocity);
	if (gSensor[trackL].velGood && gSensor[trackL].velGood)
	{
		if (gSensor[trackL].velocity > 0.3)
			gMotor[driveL1].power = gMotor[driveL2].power  = LIM_TO_VAL(sgn(gSensor[trackL].velocity) * -8, 15);
		if (gSensor[trackR].velocity > 0.3)
			gMotor[driveR1].power = gMotor[driveR2].power  = LIM_TO_VAL(sgn(gSensor[trackR].velocity) * -8, 15);
	}
}
}

/* Lift Controls */
#define LIFT_BOTTOM 800 //1100
#define LIFT_TOP (LIFT_BOTTOM + 1930)
#define LIFT_MID (LIFT_BOTTOM + 620)
#define LIFT_HOLD_DOWN_THRESHOLD (LIFT_BOTTOM + 50)
#define LIFT_HOLD_UP_THRESHOLD (LIFT_TOP - 100)

void setLift(word val)
{
	gMotor[liftR].power = gMotor[liftL].power = LIM_TO_VAL(val, 127);
}

typedef enum _tLiftStates
{
	idle = 0,
	hold,
	move
} tLiftStates;

tLiftStates gLiftState = idle;

void setLiftState(tLiftStates state, word val = 0)
{
	gLiftState = state;
	switch (gLiftState)
	{
	case 0: //idle
		{
			setLift(0);
			break;
		}
	case 1: //hold
		{
			if (gSensor[liftPoti].value < LIFT_HOLD_DOWN_THRESHOLD) //Lift is at bottom
				setLift(!gSensor[limLift].value ? -15 : -90);
			else if (gSensor[liftPoti].value > LIFT_HOLD_UP_THRESHOLD) //Lift is at top
				setLift(gSensor[liftPoti].value >= LIFT_TOP ? 15 : 127);
			else //Lift is in middle
				setLift(gSensor[liftPoti].value > LIFT_MID ? 12 : 10);
			break;
		}
	case 2: //move
		{
			setLift(val);
			break;
		}
	}
}


void handleLift() //Decide which state to put machine in
{
	//writeDebugStreamLine("State = %d, Lift loc = %d, Lift Power = %d", gLiftState, gSensor[liftPoti].value, gMotor[liftR].power);

	word joy = gJoy[JOY_LIFT].cur;
	if (!joy || abs(gJoy[JOY_LIFT].cur) < abs(gJoy[JOY_LIFT].lst))
	{
		setLiftState(hold);
	}
	else if (joy)
	{
		if ((sgn(joy) == -1 && gSensor[liftPoti].value < LIFT_HOLD_DOWN_THRESHOLD) || (sgn(joy) == 1 && gSensor[liftPoti].value > LIFT_HOLD_UP_THRESHOLD))
			setLiftState(hold);
		else
			setLiftState(move, joy);
	}
}

/* Arm Controls */
#define RL_ARM_TOP 2700
#define ARM_TOP (RL_ARM_TOP - 100)

//Actual ARM_BOTTOM = 1020
#define ARM_BOTTOM (RL_ARM_TOP - 1450)

#define ARM_PRESTACK (RL_ARM_TOP - 800)
#define ARM_RELEASE (RL_ARM_TOP - 700)
#define ARM_CARRY (RL_ARM_TOP - 1040)
#define ARM_STACK (RL_ARM_TOP - 100)
//#define ARM_HORIZONTAL (RL_ARM_TOP - 1590)
#define ARM_HOLD_DOWN_THRESHOLD (ARM_BOTTOM + 50)

void setArm(word val)
{
	gMotor[arm].power = LIM_TO_VAL(val, 127);
}

typedef enum _tArmStates
{
	idle,
	hold,
	move,
	manual
} tArmStates;

tArmStates gArmState = idle;
int gArmTarget;
int gArmPower

#define ARM_STATE(state, target, power) gArmState = state; \
gArmTarget = target; \
gArmPower = power; \
writeDebugStreamLine ("%d Arm State:%d, loc: %d, %d, %d, %d", npgmTime, gArmState, gSensor[armPoti].value, gArmTarget, gArmPower);

task setArmState()
{
	sCycleData arm;
	initCycle(arm, 10, "arm");
	while(true)
	{
		//writeDebugStreamLine("Arm Task");
		switch (gArmState)
		{
		case 0: //idle
			{
				setArm(0);
				break;
			}
		case 1: //hold
			{
				if (gSensor[armPoti].value < ARM_HOLD_DOWN_THRESHOLD) //Arm is at bottom
					setArm(gSensor[limArm].value ? -15 : -40);
				else
					setArm(7);
				break;
			}
		case 2: //move
			{
				if (gArmTarget == -1)
				{
					ARM_STATE(hold, -1, -1);
				}
				else
				{
					int dir = (gArmTarget < gSensor[armPoti].value)? -1 : 1;
					/*
					gArmPower = abs(gArmPower) * dir;
					writeDebugStreamLine ("move: set power %d, dir %d, poti %d", gArmPower, dir, gSensor[armPoti].value);
					setArm(gArmPower);
					while ( (dir == 1)? (gSensor[armPoti].value < gArmTarget) : (gSensor[armPoti].value > gArmTarget) )
						sleep(10);
					*/
					const int kP = 0.15;
					while ( (dir == 1)? (gSensor[armPoti].value < gArmTarget) : (gSensor[armPoti].value > gArmTarget) )
					{
						int error = target - gSensor[armPoti].value;
						setArm(error * kP
						sleep(10);
					}

					ARM_STATE(hold, -1, -1);
				}
				break;
			}
		case 3: //manual
			{
				word joy = gJoy[JOY_ARM].cur;

				setArm(joy);

				if (	(sgn(joy) == -1 && gSensor[armPoti].value < (ARM_BOTTOM + 20)) || (sgn(joy) == 1 && gSensor[armPoti].value > (ARM_TOP - 20)) )
					ARM_STATE(hold, -1, -1);

				break;
			}
		}
		endCycle(arm);
	}
}


void handleArm() //Decide which state to put machine in
{
	word joy = gJoy[JOY_ARM].cur;
	if (RISING(JOY_ARM))
	{
		ARM_STATE(manual, -1, -1);
	}
	else if (!joy && gArmState == manual)//|| abs(gJoy[JOY_ARM].cur) < abs(gJoy[JOY_ARM].lst))
	{
		ARM_STATE(hold, -1, -1);
	}

	if (RISING(BTN_STACK) && gArmState != move)
	{
		writeDebugStreamLine("Stack button");
		ARM_STATE(move, ARM_CARRY, 80);
	}
}

/* Mobile Goal Controls */
#define MOBILE_TOP 2430
#define MOBILE_BOTTOM 900
#define MOBILE_MIDDLE_UP 1150
#define MOBILE_MIDDLE_DOWN 1650
#define MOBILE_MIDDLE_THRESHOLD 2250
#define MOBILE_HALFWAY 1550

#define MOBILE_UP_HOLD_POWER 12
#define MOBILE_DOWN_HOLD_POWER -15

typedef enum _tMobileStates
{
	idle,
	hold,
	moveTop,
	moveBottom,
	moveUpToMid,
	moveDownToMid,
	holdMid
}tMobileStates;

tMobileStates gMobileState = idle;

void setMobile(word val)
{
	gMotor[mobile].power = val;
}

void setMobileState()
{
	switch (gMobileState)
	{
		case 0: //idle
		{
			setMobile(0);
			break;
		}
		case 1: //hold
		{
			setMobile(gSensor[mobilePoti].value < MOBILE_HALFWAY? -5 : 5);
			break;
		}
		case 2: //moveTop
		{
			setMobile(127);
			if (gSensor[mobilePoti].value > (MOBILE_TOP - 50))
				gMobileState = hold;
			break;
		}
		case 3: //moveBottom
		{
			setMobile(-127);
			if (gSensor[mobilePoti].value < (MOBILE_BOTTOM + 50))
				gMobileState = hold;
			break;
		}
		case 4: //moveUpToMid
		{
			setMobile(127);
			if (gSensor[mobilePoti].value > MOBILE_MIDDLE_UP)
				gMobileState = holdMid;
			break;
		}
		case 5: //moveDownToMid
		{
			setMobile(-127);
			if (gSensor[mobilePoti].value < MOBILE_MIDDLE_DOWN)
				gMobileState = holdMid;
			break;
		}
		case 6: //holdMid
		{
			if (gSensor[mobilePoti].value > MOBILE_MIDDLE_DOWN-100)
				setMobile(0);
			else
				setMobile(15);
			break;
		}
	}
}

void handleMobile()
{
	if (RISING(BTN_MOBILE_TOGGLE))
	{
		writeDebugStreamLine("Toggle Mobile");
		if (gMobileState != holdMid)
		{
			gMobileState = (gSensor[mobilePoti].value < MOBILE_HALFWAY)? moveTop : moveBottom;
			writeDebugStreamLine("Mobile state: %d", gMobileState);
		}
		else
		{
			gMobileState = moveTop;
		}
	}
	if (RISING(BTN_MOBILE_MIDDLE))
	{
		if (gMobileState != holdMid)
			gMobileState = (gSensor[mobilePoti].value < MOBILE_HALFWAY)? moveUpToMid : moveDownToMid;
		else
			gMobileState = moveBottom;
	}
}

void startup()
{
	clearDebugStream();
	setupSensors();
	setupMotors();
	setupJoysticks();
	tInit();

	//Setup Joysticks & Buttons
	enableJoystick(JOY_THROTTLE);
	enableJoystick(JOY_TURN);
	enableJoystick(JOY_LIFT);
	enableJoystick(JOY_ARM);
	enableJoystick(BTN_MOBILE_TOGGLE);
	enableJoystick(BTN_MOBILE_MIDDLE);
	enableJoystick(BTN_STACK);
	MIRROR(BTN_MOBILE_TOGGLE);
	MIRROR(BTN_MOBILE_MIDDLE);
	MIRROR(BTN_STACK);

	gJoy[JOY_THROTTLE].deadzone = 15;
	gJoy[JOY_TURN].deadzone = 15;
	gJoy[JOY_LIFT].deadzone = 25;
	gJoy[JOY_ARM].deadzone = 25;
}

void disabled()
{
	updateSensorInputs();
	//selectAuto();
	//handleLcd();
}

task autonomous()
{
sCycleData cycle;
initCycle(cycle, 10, "autonomous");

	while(true)
	{
		endCycle(cycle);
	}
}

task usercontrol()
{
	sCycleData cycle;
	initCycle(cycle, 10, "usercontrol");

	tStart(setArmState);

	while (true)
	{
		updateJoysticks();
		updateMotors();
		updateSensorInputs();
		updateSensorOutputs();

		handleDrive();
		handleLift();
		handleArm();
		handleMobile();

		setMobileState();

		endCycle(cycle);
	}

	tStop(setArmState);
}
