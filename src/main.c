#pragma config(Sensor, in1,    leftLight,      sensorReflection)
#pragma config(Sensor, in2,    midLight,       sensorReflection)
#pragma config(Sensor, in3,    rightLight,     sensorReflection)
#pragma config(Sensor, in4,    wristPoti,      sensorPotentiometer)
#pragma config(Sensor, in6,    gyro,           sensorGyro)
#pragma config(Sensor, dgtl1,  rightEnc,       sensorQuadEncoder)
#pragma config(Sensor, dgtl3,  leftEnc,        sensorQuadEncoder)
#pragma config(Sensor, dgtl5,  scissorEnc,     sensorQuadEncoder)
#pragma config(Sensor, dgtl8,  Sonar,          sensorSONAR_cm)
#pragma config(Motor,  port1,           frontRight,    tmotorVex393TurboSpeed_HBridge, openLoop, reversed)
#pragma config(Motor,  port2,           backRight,     tmotorVex393TurboSpeed_MC29, openLoop, reversed)
#pragma config(Motor,  port3,           frontLeft,     tmotorVex393TurboSpeed_MC29, openLoop)
#pragma config(Motor,  port4,           backLeft,      tmotorVex393TurboSpeed_MC29, openLoop)
#pragma config(Motor,  port6,           claw,          tmotorVex393TurboSpeed_MC29, openLoop)
#pragma config(Motor,  port8,           scissorLeft,   tmotorVex393HighSpeed_MC29, openLoop)
#pragma config(Motor,  port9,           scissorRight,  tmotorVex393HighSpeed_MC29, openLoop)
#pragma config(Motor,  port10,          wrist,         tmotorVex393TurboSpeed_HBridge, openLoop)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

#define IGNORE_DISABLE

#include "Vex_Competition_Includes_Custom.c"

// Library headers
#include "task.h"
#include "async.h"
#include "motors.h"
#include "sensors.h"
#include "joysticks.h"
#include "cycle.h"
#include "utilities.h"
#include "pid.h"
#include "notify.h"

// Library source
#include "task.c"
#include "async.c"
#include "motors.c"
#include "sensors.c"
#include "joysticks.c"
#include "cycle.c"
#include "utilities.c"
#include "pid.c"
#include "notify.c"

// Controls
#include "controls.h"

unsigned long gOverAllTime;
sCycleData gMainCycle;

bool gKillDriveOnTimeout = false;

int lightVal;
int lightThresh;
int lightMin = 2000;
int lightMax = 0;
int scissorBottom = -180;
int scissorTop = 1400;

///////////////////

void setDrive (word left, word right)
{
	gMotor[frontRight].power = gMotor[backRight].power = right;
	gMotor[frontLeft].power = gMotor[backLeft].power = left;
}

void setArm (word speed, int distance)
{
	gMotor[scissorLeft].power = gMotor[scissorRight].power = speed;
	if (speed > 0)
	{
		while (gSensor[scissorEnc].value < distance) sleep(10);
	}
	else if (speed < 0)
	{
		while (gSensor[scissorEnc].value > distance) sleep(10);
	}
	gMotor[scissorLeft].power = gMotor[scissorRight].power = 0;
}

void closeClaw (bool state)
{
	if (state == true) gMotor[claw].power = 127;
	else if (state == false) gMotor[claw].power = -127;
	unsigned long startTimer = nPgmTime;
	while (nPgmTime-startTimer < 200) sleep (10);
	gMotor[claw].power = 0;
}

void calibrate ()
{
	sCycleData cycle;
	initCycle(cycle, 10, "calibrate");

	setDrive(127, 127);
	while (gSensor[leftEnc].value < 700)
	{
		lightVal = gSensor[midLight].value;
		if (lightVal < lightMin) lightMin = lightVal;
		if (lightVal > lightMax) lightMax = lightVal;

		endCycle(cycle);
	}
	lightThresh = (lightMax + lightMin) / 2;
	setDrive (0, 0);
} // if sensorVal<1000, should be a white line

bool TimedOut(unsigned long timeOut, const string description)
{
	if (nPgmTime > timeOut)
	{
		hogCPU();
		// TODO: kill everything except drive
		if (gKillDriveOnTimeout) setDrive(0, 0);
		updateMotors();
		writeDebugStreamLine("%06d EXCEEDED TIME %d - %s", nPgmTime - gOverAllTime, timeOut - gOverAllTime, description);
		int current = nCurrentTask;
		while (true)
		{
			int next = tEls[current].parent;
			if (next == -1 || next == usercontrol) break;
			current = next;
		}
		tStopAll(current);
		return true;
	}
	else
		return false;
}

// Auto
#include "auto.h"
#include "auto_runs.h"

#include "auto.c"
#include "auto_runs.c"

// This function gets called 2 seconds after power on of the cortex and is the first bit of code that is run
void startup()
{
	clearDebugStream();
	writeDebugStreamLine("Code start");

	// Setup and initilize the necessary libraries
	setupMotors();
	setupSensors();
	setupJoysticks();
	tInit();

	gJoy[JOY_TURN].deadzone = DZ_TURN;
	gJoy[JOY_THROTTLE].deadzone = DZ_THROTTLE;
	gJoy[JOY_LIFT].deadzone = DZ_LIFT;
	gJoy[JOY_ARM].deadzone = DZ_ARM;

	gSensor[rightEnc].scale = -1; // set encoder to reversed
}

// This function gets called every 25ms during disabled (DO NOT PUT BLOCKING CODE IN HERE)
void disabled()
{
	displayLCDCenteredString(0, "DISABLED");
}

// This task gets started at the begining of the autonomous period
task autonomous()
{
	gAutoTime = nPgmTime;
	writeDebugStreamLine("Auto start %d", gAutoTime);
	displayLCDCenteredString(0, "AUTO");

	startSensors(); // Initilize the sensors

	gKillDriveOnTimeout = true;

	resetPosition(gPosition);
	//resetQuadratureEncoder(driveEncL);
	//resetQuadratureEncoder(driveEncR);
	//resetQuadratureEncoder(latEnc);

	tStart(autoMotorSensorUpdateTask);
	tStart(trackPositionTask);

	runAuto();

	writeDebugStreamLine("Auto: %d ms", nPgmTime - gAutoTime);

	return_t;
}

task usercontrol()//Do we need to have a usercontrol task?? Why won't it let me run if I delete it
{
	startSensors(); // Initilize the sensors
	initCycle(gMainCycle, 20, "main");

	gKillDriveOnTimeout = false;

	while (true)
	{
		updateSensorInputs();
		updateJoysticks();

		// TODO: put your main drive code here

		updateSensorOutputs();
		updateMotors();
		endCycle(gMainCycle);
	}

	return_t;
}
