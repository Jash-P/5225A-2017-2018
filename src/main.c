#pragma config(Sensor, in1,    autoPoti,       sensorPotentiometer)
#pragma config(Sensor, in2,    mobilePoti,     sensorPotentiometer)
#pragma config(Sensor, in3,    liftPoti,       sensorPotentiometer)
#pragma config(Sensor, in4,    armPoti,        sensorPotentiometer)
#pragma config(Sensor, in5,    lsField,        sensorReflection)
#pragma config(Sensor, in6,    lsBarL,         sensorReflection)
#pragma config(Sensor, in7,    lsBarR,         sensorReflection)
#pragma config(Sensor, in8,    lsMobile,       sensorReflection)
#pragma config(Sensor, dgtl1,  trackL,         sensorQuadEncoder)
#pragma config(Sensor, dgtl3,  trackR,         sensorQuadEncoder)
#pragma config(Sensor, dgtl5,  trackB,         sensorQuadEncoder)
#pragma config(Sensor, dgtl7,  sonarL,         sensorSONAR_mm)
#pragma config(Sensor, dgtl10, jmpSkills,      sensorDigitalIn)
#pragma config(Sensor, dgtl11, sonarR,         sensorSONAR_mm)
#pragma config(Motor,  port2,           liftL,         tmotorVex393HighSpeed_MC29, openLoop, reversed)
#pragma config(Motor,  port3,           driveL1,       tmotorVex393TurboSpeed_MC29, openLoop, reversed)
#pragma config(Motor,  port4,           driveL2,       tmotorVex393TurboSpeed_MC29, openLoop)
#pragma config(Motor,  port5,           arm,           tmotorVex393HighSpeed_MC29, openLoop, reversed)
#pragma config(Motor,  port6,           mobile,        tmotorVex393HighSpeed_MC29, openLoop)
#pragma config(Motor,  port7,           driveR2,       tmotorVex393TurboSpeed_MC29, openLoop, reversed)
#pragma config(Motor,  port8,           driveR1,       tmotorVex393TurboSpeed_MC29, openLoop)
#pragma config(Motor,  port9,           liftR,         tmotorVex393HighSpeed_MC29, openLoop)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

#define CHECK_POTI_JUMPS
//#define FORCE_AUTO
//#define IGNORE_DISABLE

// Programming skills selector
// 0 - No programming skills
// 1 - Primary individual goal route (110 points)
// 2 - Secondary double goal route (? points)
#define SKILLS_ROUTE 1

// Necessary definitions

#define TID0(routine) #routine, 0
#define TID1(routine, id) #routine, id
#define TID2(routine, major, minor) #routine, ((major << 8) | minor)

// Year-independent libraries (headers)

#include "task.h"
#include "async.h"
#include "timeout.h"
#include "motors.h"
#include "sensors.h"
#include "joysticks.h"
#include "cycle.h"
#include "utilities.h"
#include "state.h"

// Timeout function

bool TimedOut(unsigned long timeOut, const unsigned char *routine, unsigned short id, bool kill = true, tTimeoutVelSourceType velSourceType = velNone, unsigned long velSourceData = 0, float vel = 0, unsigned long elpsdTime = 0);

// Year-independent libraries (source)

#include "task.c"
#include "async.c"
#include "timeout.c"
#include "motors.c"
#include "sensors.c"
#include "joysticks.c"
#include "cycle.c"
#include "utilities.c"
#include "state.c"

// Other includes

#include "Vex_Competition_Includes_Custom.c"

#include "controls.h"

#include "auto.h"
#include "auto_simple.h"
#include "auto_runs.h"
#include "custom_drive.h"
#include "custom_turning.h"
#include "diagnostics.h"

#define TRACK_IN_DRIVER

//#define ULTRASONIC_RESET

#define DATALOG_LIFT -1
#define DATALOG_ARM -1
#define DATALOG_FOLLOW -1
#define DATALOG_TURN -1
#define DATALOG_TIMEOUT -1
#define DATALOG_SWEEP -1
#define DATALOG_BATTERY -1
#define DATALOG_TEST 0

//#define LIFT_SLOW_DRIVE_THRESHOLD 1200

bool stackRunning();

typedef enum _stackFlags {
	sfNone = 0,
	sfStack = 1,
	sfDetach = 2,
	sfClear = 4,
	sfReturn = 8,
	sfMobile = 16,
	sfLoader = 32,
	sfNoResetArm = 64,
	sfNoResetLift = 128,
	sfRapid = 256,
	sfTiltAutoDrive = 512,
	sfTilt = 1024
} tStackFlags;

typedef enum _stackStates {
	stackNotRunning,
	stackPickupGround,
	stackPickupLoader,
	stackStationaryPrep,
	stackStationary,
	stackStack,
	stackDetach,
	stackClear,
	stackReturn,
	stackTiltPrep,
	stackTiltMobile,
	stackDetachMobile,
	stackWall
} tStackStates;

DECLARE_MACHINE(stack, tStackStates)

#define STACK_CLEAR_CONFIG(flags, mobileState, mobileFlags) ((flags) | sfClear | sfMobile | ((mobileState) << 16) | ((mobileFlags) << 24))
#define STACK_RAPID_CONFIG(flags, maxCones) ((flags) | sfStack | sfRapid | ((maxCones) << 12))
#define MAX_STACK 11

sCycleData gMainCycle;
int gNumCones = 0;
bool gSetTimedOut = false;

#define DRIVE_TURN_BRAKE 6

bool gDriveManual;
bool gWall;

bool isMobileSlow();

/* Drive */
void setDrive(word left, word right, bool debug = false)
{
	if (debug)
		writeDebugStreamLine("DRIVE %d %d", left, right);
	gMotor[driveL1].power = gMotor[driveL2].power = left;
	gMotor[driveR1].power = gMotor[driveR2].power = right;
}

void handleDrive()
{
	if (gDriveManual)
	{
		//gJoy[JOY_TURN].deadzone = MAX(abs(gJoy[JOY_THROTTLE].cur) / 2, DZ_ARM);
		short y = lookupDrive(gJoy[JOY_THROTTLE].cur);
		short a = abs(y)<gTurnCurveLim? lookupTurn(gJoy[JOY_TURN].cur): gJoy[JOY_TURN].cur;

#if defined(DRIVE_TURN_BRAKE) && DRIVE_TURN_BRAKE > 0
#ifndef TRACK_IN_DRIVER
#error "Turn braking requires track in driver!"
#endif
		if (!a && abs(gVelocity.a) > 0.5)
			a = -DRIVE_TURN_BRAKE * sgn(gVelocity.a);
#endif

		word l = y + a;
		word r = y - a;

		//if (gSensor[liftPoti].value > LIFT_SLOW_DRIVE_THRESHOLD)
		//{
		//	LIM_TO_VAL_SET(l, 40);
		//	LIM_TO_VAL_SET(r, 40);
		//}
		setDrive(l, r);
	}
}


/* Lift */
typedef enum _tLiftStates {
	liftManaged,
	liftIdle,
	liftManual,
	liftRaiseSimpleState,
	liftLowerSimpleState,
	liftToTarget,
	liftHold,
	liftHoldDown,
	liftHoldUp,
} tLiftStates;

void setLift(word power,bool debug=true)
{
	if( debug ) writeDebugStreamLine("%06d Lift %4d", nPgmTime,power );
	gMotor[liftL].power = gMotor[liftR].power = power;
	writeDebugStreamLine("%d", power);
}

#define LIFT_BOTTOM 1010
#define LIFT_TOP (LIFT_BOTTOM + 1820)
#define LIFT_MID (LIFT_BOTTOM + 790)
#define LIFT_HOLD_DOWN_THRESHOLD (LIFT_BOTTOM + 50)
#define LIFT_HOLD_UP_THRESHOLD (LIFT_TOP - 100)
#define LIFT_LOADER (LIFT_BOTTOM + 1100)
#define LIFT_LOADER_PICKUP (LIFT_BOTTOM + 650)
#define LIFT_RETURN (LIFT_BOTTOM + 500)
#define LIFT_MOBILE_TILT (LIFT_BOTTOM + 200)

DECLARE_MACHINE(lift, tLiftStates)

void liftRaiseSimple(int target, word mainPower, word brakePower)
{
	writeDebugStreamLine("Raising lift to %d", target);
	setLift(mainPower);
	int pos;
	while ((pos = gSensor[liftPoti].value) < target) sleep(10);
	if (brakePower)
	{
		setLift(brakePower);
		sleep(200);
	}
	writeDebugStreamLine("Lift moved up to %d | %d", target, pos);
}

NEW_ASYNC_VOID_STATE_3(lift, liftRaiseSimpleState, liftRaiseSimple, int, word, word);

void liftLowerSimple(int target, word mainPower, word brakePower)
{
	writeDebugStreamLine("Lowering lift to %d", target);
	setLift(mainPower);
	int pos;
	while ((pos = gSensor[liftPoti].value) > target) sleep(10);
	if (brakePower)
	{
		setLift(brakePower);
		sleep(200);
	}
	writeDebugStreamLine("Lift moved down to %d | %d", target, pos);
}

NEW_ASYNC_VOID_STATE_3(lift, liftLowerSimpleState, liftLowerSimple, int, word, word);

MAKE_MACHINE(lift, tLiftStates, liftIdle,
{
case liftIdle:
	setLift(0);
	break;
case liftRaiseSimpleState:
	{
		STATE_INVOKE_ASYNC(liftRaiseSimple);
		NEXT_STATE(liftHold);
	}
case liftLowerSimpleState:
	{
		STATE_INVOKE_ASYNC(liftLowerSimple);
		NEXT_STATE(liftHold);
	}
case liftToTarget:
	{
		int target = arg;
		int err;
		writeDebugStreamLine("%d Moving lift to %d", nPgmTime, target);
		velocityClear(liftPoti);
		do
		{
			err = target - gSensor[liftPoti].value;
			float vTarget = sgn(err) * 4.0 * (1.0 - exp(-0.0025 * abs(err)));
			const float bias = 8;
			const float kB = 15.0;
			const float kP = 10.0;
			velocityCheck(liftPoti);
			tHog();
			if (DATALOG_LIFT != -1)
			{
				datalogDataGroupStart();
				datalogAddValue(DATALOG_LIFT + 0, err);
				datalogAddValue(DATALOG_LIFT + 1, vTarget * 1000);
			}
			if (gSensor[liftPoti].velGood)
			{
				float power = kB * vTarget + kP * (vTarget - gSensor[liftPoti].velocity) + bias;

				if (power * sgn(err) < 25 && gSensor[liftPoti].velocity * sgn(err) < abs(vTarget))
					power = 25 * sgn(err);
				else if (sgn(power) == -sgn(vTarget))
					LIM_TO_VAL_SET(power, 7);
				else if (sgn(power) == -sgn(gSensor[liftPoti].velocity))
					LIM_TO_VAL_SET(power, 25);
				else
					LIM_TO_VAL_SET(power, 127);
				setLift((word) power);
				if (DATALOG_LIFT != -1)
				{
					datalogAddValue(DATALOG_LIFT + 2, gSensor[liftPoti].velocity * 1000);
					datalogAddValue(DATALOG_LIFT + 3, power * 10);
				}
			}
			if (DATALOG_LIFT != -1)
				datalogDataGroupEnd();
			tRelease();
			sleep(20);
		} while (abs(err) > 100);
		writeDebugStreamLine("%d Stopping lift", nPgmTime);
		if (gSensor[liftPoti].velGood)
		{
			setLift(sgn(gSensor[liftPoti].velocity) > 0 ? -15 : 10);
			sleep(150);
			setLift(0);
		}
		writeDebugStreamLine("%d Moved lift to %d | %d", nPgmTime, target, gSensor[liftPoti].value);
		NEXT_STATE(liftHold);
	}
case liftHold:
	{
		int target = gSensor[liftPoti].value;
		if (target < LIFT_HOLD_DOWN_THRESHOLD)
			NEXT_STATE(liftHoldDown);
		if (target > LIFT_HOLD_UP_THRESHOLD)
			NEXT_STATE(liftHoldUp);
		setLift(6 + (word)(3 * cos((MIN(target - LIFT_MID, 0)) * PI / 2700)));
		break;
	}
case liftHoldDown:
	setLift(-15);
	break;
case liftHoldUp:
	setLift(15);
	break;
})

void handleLift()
{
	if (liftState == liftManaged || stackRunning()) return;

	if (RISING(JOY_LIFT_DRIVER) || RISING(JOY_LIFT_PARTNER))
	{
		liftSet(liftManual);
	}
	if (liftState == liftManual && !gJoy[JOY_LIFT_DRIVER].cur && !gJoy[JOY_LIFT_PARTNER].cur)
	{
		liftSet(liftHold, -1);
	}

	if (liftState == liftManual)
	{
		word value = gJoy[JOY_LIFT_DRIVER].cur ? gJoy[JOY_LIFT_DRIVER].cur : gJoy[JOY_LIFT_PARTNER].cur;
		value = value * 2 - 128 * sgn(value);
		if (gSensor[liftPoti].value <= LIFT_BOTTOM && value < -15) value = -15;
		if (gSensor[liftPoti].value >= LIFT_TOP && value > 15) value = 15;
		setLift(value);
	}
}


/* Arm */
typedef enum _tArmStates {
	armManaged,
	armIdle,
	armManual,
	armToTarget,
	armRaiseSimpleState,
	armLowerSimpleState,
	armFollowMobile,
	armStopping,
	armHold,
	armHoldDown,
	armHoldMobile
} tArmStates;

#define RL_ARM_TOP 2910
#define ARM_TOP (RL_ARM_TOP - 160)

//Actual ARM_BOTTOM = 1020
#define ARM_BOTTOM (RL_ARM_TOP - 1640)

#define ARM_PRESTACK (RL_ARM_TOP - 640)
#define ARM_RELEASE (RL_ARM_TOP - 740)
#define ARM_CARRY (RL_ARM_TOP - 1140)
#define ARM_STACK (RL_ARM_TOP - 160)
#define ARM_HORIZONTAL (RL_ARM_TOP - 1490)
#define ARM_FOLLOW_TARGET (RL_ARM_TOP - 890)
#define ARM_HOLD_DOWN_THRESHOLD (RL_ARM_TOP - 1500)
#define ARM_MOBILE_TILT (RL_ARM_TOP - 730)

#define ARM_MOBILE_RATIO 0.371

tArmStates gArmSimpleNextState = armIdle;

void setArm(word power, bool debug = false)
{
	if( debug ) writeDebugStreamLine("%06d Arm  %4d", nPgmTime, power);
	gMotor[arm].power = power;
	//	motor[arm]=power;
}

DECLARE_MACHINE(arm, tArmStates)

void armRaiseSimple(int target, word mainPower, word brakePower, float earlyDrop, unsigned long brakeDelay, tArmStates next)
{
	setArm(mainPower);
	int pos;
	velocityClear(armPoti);
	do
	{
		sleep(10);
		pos = gSensor[armPoti].value;
		velocityCheck(armPoti);
		if (gSensor[armPoti].velGood && pos + gSensor[armPoti].velocity * earlyDrop > target)
			break;
	}	while (pos < target);
	if (brakePower)
	{
		setArm(brakePower);
		sleep(brakeDelay);
		setArm(0);
	}
	writeDebugStreamLine("Arm moved up to %d | %d", target, pos);
	gArmSimpleNextState = next;
}

NEW_ASYNC_VOID_STATE_6(arm, armRaiseSimpleState, armRaiseSimple, int, word, word, float, unsigned long, tArmStates);

unsigned long armRaiseSimpleAsync(int target, word mainPower, word brakePower)
{
	return armRaiseSimpleAsync(target, mainPower, brakePower, 0, 200, armHold);
}

void armLowerSimple(int target, word mainPower, word brakePower, float earlyDrop, unsigned long brakeDelay, tArmStates next)
{
	setArm(mainPower);
	int pos;
	velocityClear(armPoti);
	do
	{
		sleep(10);
		pos = gSensor[armPoti].value;
		velocityCheck(armPoti);
		if (gSensor[armPoti].velGood && pos + gSensor[armPoti].velocity * earlyDrop < target)
			break;
	} while (pos > target);
	if (brakePower)
	{
		setArm(brakePower);
		sleep(brakeDelay);
	}
	writeDebugStreamLine("Arm moved down to %d | %d", target, pos);
	gArmSimpleNextState = next;
}

NEW_ASYNC_VOID_STATE_6(arm, armLowerSimpleState, armLowerSimple, int, word, word, float, unsigned long, tArmStates);

unsigned long armLowerSimpleAsync(int target, word mainPower, word brakePower)
{
	return armLowerSimpleAsync(target, mainPower, brakePower, 0, 200, armHold);
}

MAKE_MACHINE(arm, tArmStates, armIdle,
{
case armIdle:
	setArm(0);
	break;
case armToTarget:
	{
		int target = arg;
		int err;
		writeDebugStreamLine("%d Moving arm to %d", nPgmTime, target);
		velocityClear(armPoti);
		do
		{
			err = target - gSensor[armPoti].value;
			float vTarget = sgn(err) * 5.5 * (1.0 - exp(-0.0005 * abs(err)));
			const float bias = 3;
			const float kB = 30.0;
			const float kP = 8.0;
			velocityCheck(armPoti);
			tHog();
			if (DATALOG_ARM != -1)
			{
				datalogDataGroupStart();
				datalogAddValue(DATALOG_ARM + 0, err);
				datalogAddValue(DATALOG_ARM + 1, vTarget * 1000);
			}
			if (gSensor[armPoti].velGood)
			{
				float power = kB * vTarget + kP * (vTarget - gSensor[armPoti].velocity) + bias;

				if (power * sgn(err) < 20 && gSensor[armPoti].velocity * sgn(err) < abs(vTarget))
					power = 20 * sgn(err);
				else if (sgn(power) == -sgn(gSensor[armPoti].velocity))
					LIM_TO_VAL_SET(power, 20);
				else
					LIM_TO_VAL_SET(power, 127);
				setArm((word) power);
				if (DATALOG_ARM != -1)
				{
					datalogAddValue(DATALOG_ARM + 2, gSensor[armPoti].velocity * 1000);
					datalogAddValue(DATALOG_ARM + 3, power * 10);
				}
			}
			if (DATALOG_ARM != -1)
				datalogDataGroupEnd();
			tRelease();
			sleep(20);
		} while (abs(err) > 100);
		writeDebugStreamLine("%d Stopping arm", nPgmTime);
		if (gSensor[armPoti].velGood)
		{
			setArm(sgn(gSensor[armPoti].velocity) > 0 ? -10 : 20);
			sleep(150);
			setArm(0);
		}
		writeDebugStreamLine("%d Moved arm to %d | %d", nPgmTime, target, gSensor[armPoti].value);
		NEXT_STATE(armHold);
	}
case armRaiseSimpleState:
	{
		STATE_INVOKE_ASYNC(armRaiseSimple);
		NEXT_STATE(gArmSimpleNextState);
	}
case armLowerSimpleState:
	{
		STATE_INVOKE_ASYNC(armLowerSimple);
		NEXT_STATE(gArmSimpleNextState);
	}
case armFollowMobile:
	{
		velocityClear(armPoti);
		velocityClear(mobilePoti);
		while (isMobileSlow())
		{
			velocityCheck(armPoti);
			velocityCheck(mobilePoti);
			if (gSensor[mobilePoti].velGood && gSensor[armPoti].velGood)
			{
				const float kP_vel = 0.01;
				const float kB = 5.0;
				const float kP = 4.0;
				tHog();
				if (DATALOG_FOLLOW != -1)
				{
					datalogDataGroupStart();
					datalogAddValue(DATALOG_FOLLOW + 0, gSensor[mobilePoti].velocity * 1000);
				}
				float vTarget = gSensor[mobilePoti].velocity * ARM_MOBILE_RATIO + kP_vel * (ARM_FOLLOW_TARGET + (gSensor[mobilePoti].value - 500) * ARM_MOBILE_RATIO - gSensor[armPoti].value);
				float power = kB * vTarget + kP * (vTarget - gSensor[armPoti].velocity);
				LIM_TO_VAL_SET(power, 127);
				if (DATALOG_FOLLOW != -1)
				{
					datalogAddValue(DATALOG_FOLLOW + 1, gSensor[armPoti].velocity * 1000);
					datalogAddValue(DATALOG_FOLLOW + 2, vTarget * 1000);
					datalogAddValue(DATALOG_FOLLOW + 3, power * 10);
					datalogDataGroupEnd();
				}
				tRelease();
				setArm((word)power);
			}
			sleep(20);
		}
		NEXT_STATE(armHold);
	}
case armStopping:
	velocityClear(armPoti);
	do
	{
		sleep(5);
		velocityCheck(armPoti);
	} while (!gSensor[armPoti].velGood);
	setArm(sgn(gSensor[armPoti].velocity) * -25);
	sleep(150);
	NEXT_STATE(armHold);
case armHold:
	{
		//const float kP = -5;
		//velocityClear(armPoti);
		//sCycleData cycle;
		//initCycle(cycle, 10, "armHold");
		//while (true)
		//{
		//	velocityCheck(armPoti);
		//	if (gSensor[armPoti].velGood) {
		//		float power = 5 + gSensor[armPoti].velocity * kP;
		//		LIM_TO_VAL_SET(power, 12);
		//		setArm((word)power);
		//	}
		//	endCycle(cycle);
		//}
		if (gSensor[armPoti].value < ARM_HOLD_DOWN_THRESHOLD)
			NEXT_STATE(armHoldDown)
		setArm(7);
		break;
	}
case armHoldDown:
	setArm(-15);
	break;
case armHoldMobile:
	setArm(-15);
	break;
})

void handleArm()
{
	if (armState == armManaged || stackRunning()) return;

	if (RISING(JOY_ARM_DRIVER) || RISING(JOY_ARM_PARTNER))
	{
		armSet(armManual);
	}
	if (armState == armManual && !gJoy[JOY_ARM_DRIVER].cur && !gJoy[JOY_ARM_PARTNER].cur)
	{
		armSet(armHold, -1);
	}

	if (armState == armManual)
	{
		word value = gJoy[JOY_ARM_DRIVER].cur ? gJoy[JOY_ARM_DRIVER].cur : gJoy[JOY_ARM_PARTNER].cur;
		value = value * 2 - 128 * sgn(value);
		if (gSensor[armPoti].value >= ARM_TOP && value > 10) value = 10;
		if (gSensor[armPoti].value <= ARM_BOTTOM && value < -10) value = -10;
		setArm(value);
	}
}


/* Mobile */

typedef enum _tMobileFlags {
	mfNone = 0,
	mfClear = 1,
	mfFollow = 2
} tMobileFlags;

typedef enum _tMobileStates {
	mobileManaged,
	mobileIdle,
	mobileTop,
	mobileBottom,
	mobileBottomSlow,
	mobileUpToMiddle,
	mobileDownToMiddle,
	mobileMiddle
} tMobileStates;

#define MOBILE_TOP 2450
#define MOBILE_BOTTOM 800
#define MOBILE_MIDDLE_UP 1000
#define MOBILE_MIDDLE_DOWN 1400
#define MOBILE_MIDDLE_THRESHOLD 2100
#define MOBILE_HALFWAY 1400

#define MOBILE_UP_POWER 127
#define MOBILE_DOWN_POWER -127
#define MOBILE_UP_HOLD_POWER 12
#define MOBILE_DOWN_HOLD_POWER -15
#define MOBILE_DOWN_SLOW_POWER_1 -60
#define MOBILE_DOWN_SLOW_POWER_2 6

#define MOBILE_LIFT_CHECK_THRESHOLD 1900
#define LIFT_MOBILE_THRESHOLD (LIFT_BOTTOM + 600)

#define MOBILE_SLOW_HOLD_TIMEOUT 500
#define MOBILE_AUTO_TIMEOUT 500

// NUMBER OF CONES          0  1  2  3  4  5  6  7  8  9  10 11
int gMobileSlowDown[12]  = {0, 0, 0, 5, 7, 7, 7, 7, 8, 8, 8, 8};

bool gMobileCheckLift;
bool gMobileSlow = false;
bool gMobileAutoEnabled = true;
unsigned long gMobileAutoTimeout = 0;
unsigned long gMobileAutoIgnore = 0;

void setMobile(word power, bool debug = false)
{
	//writeDebugStreamLine("MOBILE %d", power);
	gMotor[mobile].power = power;
}

void mobileClearLift()
{
	writeDebugStreamLine("mobileClearLift");
	if (gMobileCheckLift && gSensor[liftPoti].value < LIFT_MOBILE_THRESHOLD)
	{
		liftRaiseSimpleAsync(LIFT_MOBILE_THRESHOLD, 80, -15);
		unsigned long timeout = nPgmTime + 1000;
		liftTimeoutWhile(liftRaiseSimpleState, timeout, TID0(mobileClearLift));
	}
}

DECLARE_MACHINE(mobile, tMobileStates)

MAKE_MACHINE(mobile, tMobileStates, mobileIdle,
{
case mobileIdle:
	setMobile(0);
	break;
case mobileTop:
	{
		gMobileAutoEnabled = false;
		if (arg & mfClear)
			mobileClearLift();
		setMobile(MOBILE_UP_POWER);
		unsigned long timeout = nPgmTime + 1100;

		while (gSensor[mobilePoti].value < MOBILE_TOP - 600 && !TimedOut(timeout, TID1(mobileTop, 1), false)) sleep(10);
		//Coast if timedout
		if ( TimedOut(timeout, TID1(mobileTop, 2), False) )
			NEXT_STATE(mobileIdle)
		else
			setMobile(MOBILE_UP_HOLD_POWER);

		//if (gSensor[jmpSkills].value)
		//	liftLowerSimpleAsync(LIFT_BOTTOM, -127, 0);
		break;
	}
case mobileBottom:
	{
		gNumCones = 0;
		gMobileAutoIgnore = nPgmTime + 1500;
		if (gMobileSlow)
			NEXT_STATE(mobileBottomSlow)
		if ((arg & mfClear) && gSensor[mobilePoti].value > MOBILE_LIFT_CHECK_THRESHOLD)
			mobileClearLift();
		writeDebugStreamLine("mobileBottom %d", gNumCones);
		setMobile(MOBILE_DOWN_POWER);
		unsigned long timeout = nPgmTime + 1100;
		timeoutWhileGreaterThanL(VEL_NONE, 0, &gSensor[mobilePoti].value, MOBILE_BOTTOM, timeout, TID0(mobileBottom), false);
		//Coast if timedout
		if ( TimedOut(timeout, TID0(mobileBottom), False) )
			NEXT_STATE(mobileIdle)
		else
			setMobile(MOBILE_DOWN_HOLD_POWER);
		break;
	}
case mobileBottomSlow:
	{
		gMobileSlow = false;
		if ((arg & mfClear) && gSensor[mobilePoti].value > MOBILE_LIFT_CHECK_THRESHOLD)
			mobileClearLift();
		writeDebugStreamLine("mobileBottomSlow %d", gNumCones);
		if (arg & mfFollow)
			armSet(armFollowMobile);
		setMobile(-127);
		unsigned long timeout = nPgmTime + 500;
		timeoutWhileGreaterThanL(VEL_NONE, 0, &gSensor[mobilePoti].value, MOBILE_TOP - 200, timeout, TID1(mobileBottomSlow, 1));
		setMobile(-45);
		timeout = nPgmTime + 2500;
		timeoutWhileGreaterThanL(VEL_NONE, 0, &gSensor[mobilePoti].value, MOBILE_HALFWAY + 200, timeout, TID1(mobileBottomSlow, 2));
		setMobile(gMobileSlowDown[gNumCones]);
		timeoutWhileGreaterThanL(VEL_NONE, 0, &gSensor[mobilePoti].value, MOBILE_BOTTOM + 200, timeout, TID1(mobileBottomSlow, 3));
		setMobile(0);
		timeoutWhileGreaterThanL(VEL_NONE, 0, &gSensor[mobilePoti].value, MOBILE_BOTTOM, timeout, TID1(mobileBottomSlow, 4));
		arg = mfNone;
		NEXT_STATE(mobileBottom)
	}
case mobileUpToMiddle:
	{
		setMobile(MOBILE_UP_POWER);
		unsigned long timeout = nPgmTime + 1000;
		timeOutWhileLessThanL(VEL_NONE, 0, &gSensor[mobilePoti].value, MOBILE_MIDDLE_UP, timeout, TID0(mobileUpToMiddle));
		//while (gSensor[mobilePoti].value < MOBILE_MIDDLE_UP && !TimedOut(timeout, TID0(mobileUpToMiddle))) sleep(10);
		setMobile(15);
		NEXT_STATE(mobileMiddle)
	}
case mobileDownToMiddle:
	{
		if (arg & mfClear)
			mobileClearLift();
		setMobile(MOBILE_DOWN_POWER);
		unsigned long timeout = nPgmTime + 1000;
		timeOutWhileGreaterThanL(VEL_NONE, 0, &gSensor[mobilePoti].value, MOBILE_MIDDLE_DOWN, timeout, TID0(mobileUpToMiddle));
		//while (gSensor[mobilePoti].value > MOBILE_MIDDLE_DOWN && !TimedOut(timeout, TID0(mobileUpToMiddle))) sleep(10);
		setMobile(15);
		NEXT_STATE(mobileMiddle)
	}
case mobileMiddle:
	while (gSensor[mobilePoti].value < MOBILE_MIDDLE_THRESHOLD) sleep(10);
	arg = mfClear;
	NEXT_STATE(mobileTop)
})

void mobileWaitForSlowHold(TVexJoysticks btn)
{
	unsigned long timeout = nPgmTime + MOBILE_SLOW_HOLD_TIMEOUT;
	while (nPgmTime < timeout)
	{
		if (!gJoy[btn].cur) return;
		sleep(10);
	}
	gMobileSlow = true;
	if (mobileState == mobileBottom)
		mobileSet(mobileBottomSlow);
	writeDebugStreamLine("mobileBottomSlow activated");
}

NEW_ASYNC_VOID_1(mobileWaitForSlowHold, TVexJoysticks);

void handleMobile()
{
	if (mobileState == mobileManaged || nPgmTime < gMobileAutoTimeout)
		return;

	//if (!gSensor[limMobile].value && gSensor[mobilePoti].value < MOBILE_BOTTOM + 200 && nPgmTime > gMobileAutoIgnore)
	//	gMobileAutoEnabled = true;
	//if (gMobileAutoEnabled && gSensor[limMobile].value && gSensor[jmpSkills].value)
	//{
	//	mobileSet(mobileTop, -1);
	//	gMobileAutoTimeout = nPgmTime + MOBILE_AUTO_TIMEOUT;
	//	playSound(soundUpwardTones);
	//	return;
	//}

	if (mobileState == mobileUpToMiddle || mobileState == mobileDownToMiddle || mobileState == mobileMiddle)
	{
		if (RISING(BTN_MOBILE_MIDDLE))
			mobileSet(mobileTop, mfClear);
		if (RISING(BTN_MOBILE_TOGGLE))
		{
			gMobileSlow = false;
			stackSet(stackDetach, STACK_CLEAR_CONFIG(sfNone, mobileBottom, mfClear));
			mobileWaitForSlowHoldAsync(BTN_MOBILE_MIDDLE);
		}
	}
	else
	{
		if (RISING(BTN_MOBILE_TOGGLE))
		{
			if (gSensor[mobilePoti].value > MOBILE_HALFWAY)
			{
				if (gNumCones > 3)
#ifdef ENABLE_FOLLOW
				stackSet(stackDetach, STACK_CLEAR_CONFIG(sfNoResetArm, mobileBottomSlow, gNumCones > 9 ? mfClear | mfFollow : mfClear));
#else
				stackSet(stackDetach, STACK_CLEAR_CONFIG(sfNone, mobileBottomSlow, mfClear));
#endif
				else
				{
					gMobileSlow = false;
					stackSet(stackDetach, STACK_CLEAR_CONFIG(sfNone, mobileBottom, mfClear));
					mobileWaitForSlowHoldAsync(BTN_MOBILE_TOGGLE);
				}
			}
			else
				mobileSet(mobileTop, mfClear);
		}
		if (RISING(BTN_MOBILE_MIDDLE))
		{
			if (gSensor[mobilePoti].value > MOBILE_HALFWAY)
			{
				stackSet(stackDetach, STACK_CLEAR_CONFIG(sfNone, mobileDownToMiddle, mfClear));
			}
			else
				mobileSet(mobileUpToMiddle, mfClear);
		}
	}
}

bool isMobileSlow()
{
	return mobileState == mobileBottomSlow;
}


/* Macros + Autonomous */

bool gLiftAsyncDone;
bool gContinueLoader = false;
bool gLiftTargetReached;

bool gKillDriveOnTimeout = false;

// STACKING ON                     0     1     2     3     4     5     6     7     8     9     10
const int gLiftRaiseTarget[11] = { 1300, 1400, 1550, 1650, 1800, 1900, 2000, 2150, 2300, 2450, LIFT_TOP };
const int gLiftPlaceTarget[11] = { 1010, 1080, 1200, 1350, 1500, 1650, 1750, 1850, 1950, 2100, 2200 };
const int gLiftRaiseTargetS[5] = { 2250, 2350, 2700, 2900, LIFT_TOP }; // UPDATE
const int gLiftPlaceTargetS[5] = { 1900, 2000, 2150, 2350, 2550 }; // UPDATE

bool gStack = false;
bool gLoader = false;
unsigned long gPrepStart = 0;

#define RAPID (gStack || ((arg & sfRapid) && gNumCones < ((arg >> 12) & 0xF)))

MAKE_MACHINE(stack, tStackStates, stackNotRunning,
{
case stackNotRunning:
	writeDebugStreamLine("%06d stackNotRunning %x %d", npgmTime, arg, gNumCones);
	if (!(arg & sfNoResetLift))
		liftSet(liftHold);
	if (!(arg & sfNoResetArm))
		armSet(armHold);
	gDriveManual = true;
	break;
case stackPickupGround:
	{
		writeDebugStreamLine("%06d stackPickupGround %x %d", npgmTime, arg, gNumCones);
		unsigned long armTimeOut;
		unsigned long liftTimeOut;

		//if (gSensor[armPoti].value > ARM_PRESTACK - 300)
		//{
		//	if (gSensor[armPoti].value > LIFT_BOTTOM + 200)
		//		armSet(armToTarget, ARM_HORIZONTAL);
		//	else
		//		armLowerSimpleAsync(ARM_HORIZONTAL, -80, 0);
		//	armTimeOut = nPgmTime + 1000;
		//	timeoutWhileGreaterThanL(VEL_SENSOR(armPoti), 0.5, &gSensor[armPoti].value, ARM_PRESTACK, armTimeOut, TID1(stackPickupGround, 1));
		//}
		//else if (gSensor[liftPoti].value > LIFT_BOTTOM + 200)
		//{
		//	armSet(armToTarget, ARM_HORIZONTAL);
		//}
		armLowerSimpleAsync(ARM_BOTTOM, -127, 0);
		armTimeOut = nPgmTime + 1200;
		writeDebugStreamLine("stackPickupGround 1 %06d %d", npgmTime, gSensor[armPoti].value);

		liftLowerSimpleAsync(LIFT_BOTTOM, -127, 0);
		liftTimeOut = nPgmTime + 1200;
		timeoutWhileGreaterThanL(VEL_SENSOR(liftPoti), 0.5, &gSensor[liftPoti].value, LIFT_BOTTOM, liftTimeOut, TID1(stackPickupGround, 2));

		writeDebugStreamLine("stackPickupGround 2 %06d %d", npgmTime, gSensor[liftPoti].value);

		//armLowerSimpleAsync(ARM_BOTTOM, -127, 0);
		//armTimeOut = nPgmTime + 1200;
		liftTimeoutWhile(liftLowerSimpleState, liftTimeOut, TID1(stackPickupGround, 3));
		liftSet(liftHoldDown);
		timeoutWhileGreaterThanL(VEL_SENSOR(armPoti), 0.5, &gSensor[armPoti].value, ARM_BOTTOM, armTimeOut, TID1(stackPickupGround, 4));

		writeDebugStreamLine("stackPickupGround 3 %06d %d", npgmTime, gSensor[armPoti].value);

		armSet(armManaged);
		setArm(127);
		armTimeOut = nPgmTime + 500;
		timeoutWhileLessThanL(VEL_SENSOR(armPoti), 0.5, &gSensor[armPoti].value, ARM_HORIZONTAL, armTimeOut, TID1(stackPickupGround, 5));
		armSet(armToTarget, ARM_PRESTACK - 500);

		NEXT_STATE((arg & sfStack) ? stackStack : stackNotRunning)
	}
case stackPickupLoader:
	{
		writeDebugStreamLine("%06d stackPickupLoader %x %d", npgmTime, arg, gNumCones);
		if (gNumCones >= MAX_STACK)
			NEXT_STATE(stackNotRunning)

		unsigned long armTimeOut;
		unsigned long liftTimeOut;

		//if (gSensor[liftPoti].value < LIFT_LOADER + 200)
		//{
		//	liftRaiseSimpleAsync(LIFT_LOADER + 300, 127, -5);
		//	liftTimeOut = nPgmTime + 600;
		//	liftTimeoutWhile(liftRaiseSimpleState, liftTimeOut, TID1(stackPickupLoader, 1));
		//}

		if (gSensor[armPoti].value < ARM_BOTTOM + 200)
			armSet(armToTarget, ARM_BOTTOM);
		else
			armLowerSimpleAsync(ARM_BOTTOM, -127, 10);
		armTimeOut = nPgmTime + 1500;
		liftLowerSimpleAsync(LIFT_LOADER_PICKUP, -127, 0);
		liftTimeOut = nPgmTime + 600;
		timeoutWhileGreaterThanL(VEL_SENSOR(armPoti), 0.5, &gSensor[armPoti].value, ARM_BOTTOM + 100, armTimeOut, TID1(stackPickupLoader, 2));
		liftTimeoutWhile(liftLowerSimpleState, liftTimeOut, TID1(stackPickupLoader, 3));

		NEXT_STATE((arg & sfStack) ? stackStack : stackNotRunning)
	}
case stackStationaryPrep:
	{
		writeDebugStreamLine("%06d stackStationaryPrep %x %d", npgmTime, arg, gNumCones);
		unsigned long armTimeOut;
		unsigned long liftTimeOut;

		if (gNumCones >= 5)
			NEXT_STATE(stackNotRunning)

		armRaiseSimpleAsync(ARM_TOP, 127, 0);
		armTimeOut = nPgmTime + 1500;
		liftRaiseSimpleAsync(gLiftRaiseTargetS[gNumCones], 127, (gNumCones >= 4) ? 0 : -10);
		liftTimeOut = nPgmTime + 1500;
		armTimeoutUntil(armHold, armTimeOut, TID1(stackStationaryPrep, 1));
		liftTimeoutWhile(liftRaiseSimpleState, liftTimeOut, TID1(stackStationaryPrep, 1));
		NEXT_STATE(stackNotRunning)
	}
case stackStationary:
	{
		writeDebugStreamLine("%06d stackStationary %x %d", npgmTime, arg, gNumCones);
		unsigned long armTimeOut;
		unsigned long liftTimeOut;

		if (gNumCones >= 5)
			NEXT_STATE(stackNotRunning)

		armRaiseSimpleAsync(ARM_TOP, 127, 0);
		armTimeOut = nPgmTime + 1000;
		timeoutWhileLessThanL(VEL_SENSOR(armPoti), 0.5, &gSensor[armPoti].value, ARM_TOP - 100, armTimeOut, TID1(stackStationary, 1));
		armSet(armManaged);
		setArm(-20);
		liftLowerSimpleAsync(gLiftPlaceTargetS[gNumCones], -127, 25);
		liftTimeOut = nPgmTime + 2000;
		timeoutWhileGreaterThanL(VEL_SENSOR(liftPoti), 0.5, &gSensor[liftPoti].value, gLiftPlaceTargetS[gNumCones], liftTimeOut, TID1(stackStationary, 2));
		armLowerSimpleAsync(ARM_HORIZONTAL, -127, 25, 35, 200, armHold);
		armTimeOut = nPgmTime + 1500;
		timeoutWhileGreaterThanL(VEL_SENSOR(armPoti), 0.5, &gSensor[armPoti].value, ARM_HORIZONTAL + 300, armTimeOut, TID1(stackStationary, 3));

		++gNumCones;

		long target = (gNumCones >= 5) ? LIFT_TOP : gLiftRaiseTargetS[gNumCones];
		liftRaiseSimpleAsync(target, 127, (gNumCones >= 4) ? 0 : -15);
		liftTimeOut = nPgmTime + 2000;
		timeoutWhileLessThanL(VEL_SENSOR(liftPoti), 0.5, &gSensor[liftPoti].value, target, liftTimeOut, TID1(stackStationary, 4));

		gDriveManual = true;

		armRaiseSimpleAsync(ARM_TOP, 127, -15);
		armTimeOut = nPgmTime + 2000;
		armTimeoutWhile(armRaiseSimpleState, armTimeOut, TID1(stackStationary, 5));
		liftTimeoutWhile(liftRaiseSimpleState, liftTimeOut, TID1(stackStationary, 6));

		NEXT_STATE(stackNotRunning)
	}
case stackStack:
	{
		writeDebugStreamLine("%06d stackStack %x %d", npgmTime, arg, gNumCones);
		unsigned long armTimeOut;
		unsigned long liftTimeOut;

		if (gNumCones >= MAX_STACK)
			NEXT_STATE(stackNotRunning)

		liftRaiseSimpleAsync(gLiftRaiseTarget[gNumCones], 127, (gNumCones < MAX_STACK - 1) ? -25 : 0);
		liftTimeOut = nPgmTime + 1500;
		timeoutWhileLessThanL(VEL_SENSOR(liftPoti), 0.5, &gSensor[liftPoti].value, gLiftRaiseTarget[gNumCones] - 400, liftTimeOut, TID1(stackStack, 1));

		armRaiseSimpleAsync(ARM_STACK, 127, 0);
		armTimeOut = nPgmTime + 1000;
		timeoutWhileLessThanL(VEL_SENSOR(liftPoti), 0.5, &gSensor[liftPoti].value, gLiftRaiseTarget[gNumCones] - 100, liftTimeOut, TID1(stackStack, 2));
		timeoutWhileLessThanL(VEL_SENSOR(armPoti), 0.5, &gSensor[armPoti].value, ARM_STACK - 100, armTimeOut, TID1(stackStack, 3));

		liftLowerSimpleAsync(gLiftPlaceTarget[gNumCones], -70, 0);
		liftTimeOut = nPgmTime + 800;
		liftTimeoutWhile(liftLowerSimpleState, liftTimeOut, TID1(stackStack, 4));

		++gNumCones;

		NEXT_STATE((arg & (sfDetach | sfClear | sfReturn | sfRapid)) ? stackDetach : stackNotRunning)
	}
case stackDetach:
	writeDebugStreamLine("%06d stackDetach %x %d", npgmTime, arg, gNumCones);
	if (gNumCones > 0 && gSensor[liftPoti].value < gLiftRaiseTarget[MIN(gNumCones, MAX_STACK - 1)])
	{
		if ((arg & sfReturn) && gNumCones > 3) {
			liftLowerSimpleAsync((arg & sfLoader) ? MIN(2200, gLiftPlaceTarget[MAX(0, gNumCones - 1)]) : RAPID ? LIFT_BOTTOM : 1650, -50, 0);
		}
		else {
			liftSet(liftManaged);
			setLift(-20);
		}
		if (gNumCones < 3 && !RAPID)
			armLowerSimpleAsync((gNumCones == 3) ? ARM_RELEASE - 100 : ARM_RELEASE, -127, 45, 100, 80, armIdle);
		else
			armLowerSimpleAsync(ARM_RELEASE, -127, 0, 0, 0, armIdle);
		unsigned long armTimeOut = nPgmTime + 800;
		armTimeoutWhile(armLowerSimpleState, armTimeOut, TID0(stackDetach));
		//TODO: Add lift timeout to make sure it lowers fully
		writeDebugStreamLine("%06d Detached lift at height: %d", npgmTime, gSensor[liftPoti].value);
		liftReset();
	}
	if (RAPID) {
		bool _gStack = gStack;
		gStack = false;
		if (gNumCones < MAX_STACK) {
			if (gNumCones == MAX_STACK - 1) {
				arg &= ~sfReturn;
				arg |= sfDetach;
			}
			if (gLoader) {
				if (gNumCones > 5) {
					arg |= sfLoader;
					gLoader = false;
					NEXT_STATE(stackPickupLoader)
				}
				gStack = _gStack;
			}
			else {
				arg &= ~sfLoader;
				NEXT_STATE(stackPickupGround)
			}
		}
	}
	NEXT_STATE((arg & sfClear) ? stackClear : (arg & sfReturn) ? stackReturn : stackNotRunning)
case stackClear:
	{
		writeDebugStreamLine("%06d stackClear %x %d", npgmTime, arg, gNumCones);
		int target = gNumCones == 11 ? LIFT_TOP : gLiftRaiseTarget[gNumCones];
		liftRaiseSimpleAsync(target, 127, gNumCones <= 4 ? -15 : 0);
		unsigned long timeout = nPgmTime + 1500;
		timeoutWhileLessThanL(VEL_SENSOR(liftPoti), 0.5, &gSensor[liftPoti].value, target, timeout, TID1(stackClear, 1));

		if (gSensor[armPoti].value < ARM_STACK)
		{
			armRaiseSimpleAsync(ARM_TOP, 127, 0);
			timeout = nPgmTime + 1000;
			armTimeoutWhile(armRaiseSimpleState, timeout, TID1(stackClear, 2));
		}

		if (arg & sfMobile)
			mobileSet((tMobileStates)((arg >> 16) & 0xFF), (long)(arg >> 24));

		NEXT_STATE(stackNotRunning)
	}
case stackReturn:
	{
		writeDebugStreamLine("%06d stackReturn %x %d", npgmTime, arg, gNumCones);
		unsigned long armTimeOut;
		unsigned long liftTimeOut;

		if (gWall)
			NEXT_STATE(stackWall);

		if (gNumCones <= 3)
		{
			liftSet(liftToTarget, 1450);
			liftTimeOut = nPgmTime + 800;
			timeoutWhileLessThanL(VEL_SENSOR(liftPoti), 0.5, &gSensor[liftPoti].value, LIFT_BOTTOM + 150, liftTimeOut, TID1(stackReturn, 1));
		}

		if (arg & sfLoader)
			armLowerSimpleAsync(ARM_BOTTOM, -127, 0);
		else
			armSet(armToTarget, ARM_HORIZONTAL);
		armTimeOut = nPgmTime + 1500;

		if (gNumCones <= 3)
		{

			liftTimeoutWhile(liftToTarget, liftTimeOut, TID1(stackReturn, 2));
		}
		//else if (gNumCones <= 7 && (arg & sfLoader))
		//{
		//	liftRaiseSimpleAsync(2000, 80, -15);
		//	liftTimeOut = nPgmTime + 600;
		//	liftTimeoutWhile(liftRaiseSimpleState, liftTimeOut, TID1(stackReturn, 3));
		//}
		else
		{
			liftSet(liftToTarget, (arg & sfLoader) ? LIFT_LOADER : LIFT_RETURN);
			//liftLowerSimpleAsync((arg & sfLoader) ? 2500 : 1650, -127, 25);
			liftTimeOut = nPgmTime + 1300;
			liftTimeoutWhile(liftToTarget, liftTimeOut, TID1(stackReturn, 4));
		}
		writeDebugStreamLine("Lift height %d vs %d", gSensor[liftPoti].value, LIFT_RETURN);
		//timeoutWhileGreaterThanL(VEL_SENSOR(armPoti), 0.5, &gSensor[armPoti].value, ARM_PRESTACK, armTimeOut, TID1(stackReturn, 5));

		armTimeoutWhile(armToTarget, armTimeOut, TID1(stackReturn, 6));
		NEXT_STATE(stackNotRunning)
	}
case stackTiltPrep:
	{
		writeDebugStreamLine("%06d stackTiltPrep %x %d", npgmTime, arg, gNumCones);
		unsigned long armTimeOut;
		unsigned long liftTimeOut;
		unsigned long driveTimeout;

		if (arg & sfTiltAutoDrive)
		{
			gDriveManual = false;
			setDrive(80, 80);

			driveTimeout = nPgmTime + 1000;
			timeoutWhileFalse((bool *)&gSensor[lsField].value, driveTimeout, TID1(stackTiltPrep, 1));

			setDrive(7, 7);
		}

		armLowerSimpleAsync(ARM_HORIZONTAL, -127, 15);
		//armSet(armToTarget, ARM_HORIZONTAL);
		armTimeOut = nPgmTime + 1000;
		if (gSensor[liftPoti].value < LIFT_MOBILE_TILT)
		{
			liftRaiseSimpleAsync(LIFT_MOBILE_TILT, 127, -15);
			liftTimeOut = nPgmTime + 500;
			timeoutWhileLessThanL(VEL_NONE, 0, &gSensor[liftPoti].value, LIFT_MOBILE_TILT, liftTimeOut, TID1(stackTiltPrep, 2));
		}
		timeoutWhileGreaterThanL(VEL_NONE, 0, &gSensor[armPoti].value, ARM_HORIZONTAL + 200, armTimeOut, TID1(stackTiltPrep, 3));

		NEXT_STATE((arg & sfTilt) ? stackTiltMobile : stackNotRunning)
	}
case stackTiltMobile:
	{
		writeDebugStreamLine("%06d stackTiltMobile %x %d", npgmTime, arg, gNumCones);
		unsigned long armTimeOut;
		unsigned long liftTimeOut;
		unsigned long driveTimeout;

		liftLowerSimpleAsync(LIFT_BOTTOM, -127, 0);
		liftTimeOut = nPgmTime + 1000;
		//armLowerSimpleAsync(ARM_BOTTOM, -127, 0);
		armReset();
		timeoutWhileGreaterThanL(VEL_NONE, 0, &gSensor[liftPoti].value, LIFT_BOTTOM, liftTimeOut, TID1(stackTiltMobile, 1));
		writeDebugStreamLine("stackTiltMobile %d", gSensor[liftPoti].value);
		liftSet(liftHoldDown);

		if (arg & sfTiltAutoDrive)
		{
			moveToTargetDisSimpleAsync(gPosition.a, 9, gPosition.y, gPosition.x, 80, 0, 0, 0, 0, 0, stopNone, mttSimple);
			driveTimeout = nPgmTime + 1500;
			autoSimpleTimeoutUntil(autoSimpleNotRunning, driveTimeout, TID1(stackTiltMobile, 2));
		}

		arg |= sfNoResetLift;

		NEXT_STATE((arg & sfDetach) ? stackDetachMobile : stackNotRunning)
	}
case stackDetachMobile:
	{
		writeDebugStreamLine("%06d stackDetachMobile %x %d", npgmTime, arg, gNumCones);
		unsigned long armTimeOut;
		unsigned long liftTimeOut;

		armLowerSimpleAsync(ARM_HORIZONTAL, -127, 0);
		armTimeOut = nPgmTime + 800;
		sleep(200);
		liftRaiseSimpleAsync(LIFT_MOBILE_THRESHOLD, 127, 0);
		liftTimeOut = nPgmTime + 800;
		timeoutWhileLessThanL(VEL_NONE, 0, &gSensor[liftPoti].value, LIFT_MOBILE_THRESHOLD, liftTimeOut, TID1(stackDetachMobile, 1));
		timeoutWhileGreaterThanL(VEL_NONE, 0, &gSensor[armPoti].value, ARM_HORIZONTAL, armTimeOut, TID1(stackDetachMobile, 2));

		NEXT_STATE(stackNotRunning)
	}
case stackWall:
	{
		writeDebugStreamLine("%06d stackWall %x %d", npgmTime, arg, gNumCones);
		unsigned long armTimeOut;
		unsigned long liftTimeOut;

		armSet(armToTarget, ARM_PRESTACK - 500);
		liftLowerSimpleAsync(LIFT_BOTTOM, -127, 0);
		liftTimeOut = nPgmTime + 1000;
		timeoutWhileGreaterThanL(VEL_NONE, 0, &gSensor[liftPoti].value, LIFT_BOTTOM, liftTimeOut, TID1(stackWall, 1));
		armRaiseSimpleAsync(ARM_PRESTACK, 80, 0);
		armTimeOut = nPgmTime + 1000;
		timeoutWhileLessThanL(VEL_NONE, 0, &gSensor[armPoti].value, ARM_PRESTACK, armTimeOut, TID1(stackWall, 2));

		gWall = false;

		NEXT_STATE(stackNotRunning)
	}
})

task failTimeout()
{
	stackReset();
	liftReset();
	armReset();
	mobileReset();
	gDriveManual = true;
	if (competitionState == usercontrolState)
		competitionSet(usercontrolState);
}

bool getVelocity(tTimeoutVelSourceType velSourceType, unsigned long velSourceData, float& out)
{
	switch (velSourceType)
	{
	case velSensor:
		velocityCheck(velSourceData);
		if (gSensor[velSourceData].velGood)
		{
			out = gSensor[velSourceData].velocity;
			return true;
		}
		return false;
	case velPtr:
		out = *(float *)velSourceData;
		return true;
	case velLocalY:
		out = gVelocity.x * sin(gPosition.a) + gVelocity.y * cos(gPosition.a);
		return true;
	case velTurn:
		out = gVelocity.a;
		return true;
	default:
		return false;
	}
}

bool TimedOut(unsigned long timeOut, const unsigned char *routine, unsigned short id, bool kill, tTimeoutVelSourceType velSourceType, unsigned long velSourceData, float vel, unsigned long elpsdTime)
{
	float curVel;

	if (nPgmTime > timeOut || ( (elpsdTime > 400 && getVelocity(velSourceType, velSourceData, curVel)) ? ( abs(curVel) < abs(vel) || sgn(vel) != sgn(curVel) ) : 0 ) )
	{
		tHog();
		char description[40];
		if (id >> 8)
			snprintf(description, 40, "%s %d-%d", routine, id >> 8, (word) (id & 0xFF));
		else if (id)
			snprintf(description, 40, "%s %d", routine, (word) id);
		else
			strcpy(description, routine);
		writeDebugStream("%06d EXCEEDED TIME %d, %f - ", nPgmTime, timeOut, curVel);
		writeDebugStreamLine(description);
		if (kill)
		{
			hogCPU();
			for (tMotor x = port1; x <= port10; ++x)
				gMotor[x].power = motor[x] = 0;
			word p = nCurrentTask, t;
			do {
				t = p;
				p = tEls[t].parent;
			} while (p != -1 && p != nCurrentTask && p != main && (competitionState != usercontrolState || p != _asyncTask_competitionInternal));
			if (t == main)
			{
				stopAllButCurrentTasks();
				startTask(main);
			}
			tStart(failTimeout, true);
			tStopAll(t);
		}
		return true;
	}
	else
	{
		if (DATALOG_TIMEOUT != -1)
		{
			tHog();
			datalogAddValueWithTimeStamp(DATALOG_TIMEOUT, curVel * 1000);
			tRelease();
		}
		return false;
	}
}

bool stackRunning()
{
	return stackState != stackNotRunning;
}

bool cancel()
{
	writeDebugStream("Cancel Stack: ");
	if (stackState != stackNotRunning)
	{
		stackReset();
		gDriveManual = true;
		writeDebugStreamLine("True");
		return true;
	}
	writeDebugStreamLine("False");
	return false;
}

void handleMacros()
{
	if (RISING(BTN_MACRO_STACK) && gNumCones < MAX_STACK)
	{
		gStack = true;
		gLoader = false;
	}

	if (RISING(BTN_MACRO_LOADER) && gNumCones < MAX_STACK)
	{
		gStack = true;
		gLoader = true;
	}

	if (gStack == true && gNumCones < MAX_STACK)
	{
		if (!stackRunning())
		{
			writeDebugStreamLine("Stacking");
			if (gLoader)
				stackSet(stackPickupLoader, (gNumCones < MAX_STACK - 1) ? (gNumCones >= 4) ? sfStack | sfReturn | sfLoader : sfNone : sfStack | sfDetach);
			else
				stackSet(stackPickupGround, (gNumCones < MAX_STACK - 1) ? sfStack | sfReturn : sfStack | sfDetach);
			gStack = false;
			gLoader = false;
			gWall = false;
		}
	}

	if (gSensor[jmpSkills].value)
	{
		if (RISING(BTN_SKILLS_STACKONLY) && !stackRunning() && gNumCones < MAX_STACK)
		{
			stackSet(stackStack, (gNumCones < MAX_STACK - 1) ? sfReturn : sfNone);
		}

		if (RISING(BTN_SKILLS_TILT) && !stackRunning())
		{
			stackSet(stackTiltMobile, sfNone);
		}
	}
	else
	{
		if (RISING(BTN_GAME_WALL))
		{
			if (stackRunning())
				gWall = true;
			else
				stackSet(stackWall, sfNone);
		}

		if (RISING(BTN_GAME_STATIONARY) && !stackRunning())
		{
			if (gNumCones < ARR_LEN(gLiftRaiseTargetS))
				stackSet((gSensor[liftPoti].value < gLiftRaiseTargetS[gNumCones] - 150) ? stackStationaryPrep : stackStationary, sfNone);
		}
	}

	if (RISING(BTN_MACRO_PICKUP) && !stackRunning())
	{
		stackSet(stackPickupGround, sfNone);
	}

	if (RISING(BTN_MACRO_PREP) && !stackRunning())
	{
		liftSet(liftToTarget, LIFT_LOADER);
		armLowerSimpleAsync(ARM_BOTTOM, -127, 0);
	}

	if (RISING(BTN_MACRO_CANCEL)) cancel();

	if (RISING(BTN_MACRO_INC) && gNumCones < 11) {
		++gNumCones;
		writeDebugStreamLine("%06d gNumCones= %d",nPgmTime,gNumCones);
	}

	if (RISING(BTN_MACRO_DEC) && gNumCones > 0) {
		--gNumCones;
		writeDebugStreamLine("%06d gNumCones= %d",nPgmTime,gNumCones);
	}

	if (FALLING(BTN_MACRO_ZERO))	writeDebugStreamLine("%06d MACRO_ZERO Released",nPgmTime,gNumCones);

	if (RISING(BTN_MACRO_ZERO))
	{
		gNumCones = 0;
		writeDebugStreamLine("%06d gNumCones= %d",nPgmTime,gNumCones);
	}
}

#include "auto.c"
#include "auto_simple.c"
#include "auto_runs.c"
#include "custom_drive.c"
#include "custom_turning.c"
#include "diagnostics.c"

// This function gets called 2 seconds after power on of the cortex and is the first bit of code that is run
void startup()
{
	clearDebugStream();
	writeDebugStreamLine("Code start");

	// Setup and initilize the necessary libraries
	setupMotors();
	setupSensors();
	setupJoysticks();
	tInit();

	competitionSetup();
	mobileSetup();
	armSetup();
	liftSetup();
	stackSetup();
	autoSimpleSetup();

	setupInvertedSen(jmpSkills);
	setupDgtIn(lsField, 0, 1600);
	setupDgtIn(lsBarL, 0, 2500);
	setupDgtIn(lsBarR, 0, 2500);
	setupDgtIn(lsMobile, 0, 2100);

	velocityClear(trackL);
	velocityClear(trackR);

	updateTurnLookup();
	updateDriveLookup();

	gJoy[JOY_TURN].deadzone = DZ_TURN;
	gJoy[JOY_THROTTLE].deadzone = DZ_THROTTLE;
	gJoy[JOY_LIFT_DRIVER].deadzone = DZ_LIFT;
	gJoy[JOY_LIFT_PARTNER].deadzone = DZ_LIFT;
	gJoy[JOY_ARM_DRIVER].deadzone = DZ_ARM;
	gJoy[JOY_ARM_PARTNER].deadzone = DZ_ARM;

	enableJoystick(JOY_TURN);
	enableJoystick(JOY_THROTTLE);
	enableJoystick(JOY_LIFT_DRIVER);
	enableJoystick(JOY_LIFT_PARTNER);
	enableJoystick(JOY_ARM_DRIVER);
	enableJoystick(JOY_ARM_PARTNER);
	enableJoystick(BTN_MOBILE_TOGGLE);
	enableJoystick(BTN_MOBILE_MIDDLE);
	enableJoystick(BTN_MACRO_ZERO);
	enableJoystick(BTN_MACRO_STACK);
	enableJoystick(BTN_MACRO_LOADER);
	enableJoystick(BTN_MACRO_PREP);
	//enableJoystick(BTN_MACRO_WALL);
	enableJoystick(BTN_GAME_STATIONARY);
	enableJoystick(BTN_GAME_WALL);
	enableJoystick(BTN_MACRO_PICKUP);
	enableJoystick(BTN_MACRO_CANCEL);
	enableJoystick(BTN_MACRO_INC);
	enableJoystick(BTN_MACRO_DEC);
	MIRROR(BTN_MOBILE_TOGGLE);
	MIRROR(BTN_MOBILE_MIDDLE);
	MIRROR(BTN_MACRO_STACK);
	MIRROR(BTN_MACRO_PREP);
	//MIRROR(BTN_MACRO_WALL);
	MIRROR(BTN_MACRO_CANCEL);
	MIRROR(BTN_MACRO_INC);
	MIRROR(BTN_MACRO_DEC);
	MIRROR(Btn7L);
	MIRROR(Btn8R);
	mirrorJoystick(BTN_MACRO_ZERO, BTN_MACRO_ZERO_PARTNER);
}

// This function gets called every 25ms during disabled (DO NOT PUT BLOCKING CODE IN HERE)
void disabled()
{
	sCycleData cycle;
	initCycle(cycle, 25, "disabled");
	while (true) {
		updateSensorInputs();
		selectAuto();
		handleLcd();
		endCycle(cycle);
	}
}

// This task gets started at the begining of the autonomous period
void autonomous()
{
	gAutoTime = nPgmTime;
	writeDebugStreamLine("Auto start %d", gAutoTime);

	startSensors();

	stackReset();
	liftReset();
	armReset();
	mobileReset();
	autoSimpleReset();

	gKillDriveOnTimeout = true;
	gSetTimedOut = true;
	gTimedOut = false;

	//resetPosition(gPosition);
	//resetQuadratureEncoder(trackL);
	//resetQuadratureEncoder(trackR);
	//resetQuadratureEncoder(trackB);

	autoMotorSensorUpdateTaskAsync();
	trackPositionTaskAsync();

	runAuto();

	writeDebugStreamLine("Auto: %d ms", nPgmTime - gAutoTime);

	setDrive(0, 0);
	stackReset();
	liftReset();
	armReset();
	mobileReset();
	autoSimpleReset();

	return_t;
}

// This task gets started at the beginning of the usercontrol period
void usercontrol()
{
	gSetTimedOut = false;
	gTimedOut = false;

	startSensors(); // Initilize the sensors
#ifdef TRACK_IN_DRIVER
	initCycle(gMainCycle, 15, "main");
#else
	initCycle(gMainCycle, 10, "main");
#endif

	updateSensorInput(jmpSkills);

#ifdef TRACK_IN_DRIVER
	trackPositionTaskAsync();
#endif

	//if (gSensor[jmpSkills].value)
	//{
	//	autoMotorSensorUpdateTaskAsync();
	//	trackPositionTaskAsync();

	//	driverSkillsStart();

	//	trackPositionTaskKill();
	//	autoMotorSensorUpdateTaskKill();

	//	mobileSet(mobileTop);

	//	armSet(armHold);
	//}

	stackReset();
	liftReset();
	armReset();
	mobileReset();

	gKillDriveOnTimeout = true;
	gDriveManual = true;
	gMobileCheckLift = true;
	gMobileAutoEnabled = true;
	gStack = false;
	gLoader = false;

	while (true)
	{
		updateSensorInputs();
		updateJoysticks();

		selectAuto();

		handleDrive();
		handleLift();
		handleArm();
		handleMobile();
		handleMacros();

		handleLcd();

		updateSensorOutputs();
		updateMotors();
		endCycle(gMainCycle);
	}

	return_t;
}
