#pragma config(Sensor, in1,    autoPoti,       sensorPotentiometer)
#pragma config(Sensor, in2,    mobilePoti,     sensorPotentiometer)
#pragma config(Sensor, in3,    liftPoti,       sensorPotentiometer)
#pragma config(Sensor, in4,    armPoti,        sensorPotentiometer)
#pragma config(Sensor, in5,    clawPoti,       sensorPotentiometer)
#pragma config(Sensor, in6,    expander,       sensorAnalog)
#pragma config(Sensor, in7,    leftLine,       sensorLineFollower)
#pragma config(Sensor, in8,    rightLine,      sensorLineFollower)
#pragma config(Sensor, dgtl1,  armSonic,       sensorSONAR_mm)
#pragma config(Sensor, dgtl3,  limBottom,      sensorTouch)
#pragma config(Sensor, dgtl4,  limTop,         sensorTouch)
#pragma config(Sensor, dgtl5,  driveEncL,      sensorQuadEncoder)
#pragma config(Sensor, dgtl7,  driveEncR,      sensorQuadEncoder)
#pragma config(Sensor, dgtl9,  latEnc,         sensorQuadEncoder)
#pragma config(Sensor, dgtl11, frontSonic,     sensorSONAR_mm)
#pragma config(Motor,  port1,           arm,           tmotorVex393_HBridge, openLoop)
#pragma config(Motor,  port2,           liftL1,        tmotorVex393HighSpeed_MC29, openLoop, reversed)
#pragma config(Motor,  port3,           driveL1,       tmotorVex393HighSpeed_MC29, openLoop)
#pragma config(Motor,  port4,           driveL2,       tmotorVex393HighSpeed_MC29, openLoop, reversed)
#pragma config(Motor,  port5,           liftL2,        tmotorVex393HighSpeed_MC29, openLoop, reversed)
#pragma config(Motor,  port6,           mobile,        tmotorVex393HighSpeed_MC29, openLoop)
#pragma config(Motor,  port7,           driveR1,       tmotorVex393HighSpeed_MC29, openLoop, reversed)
#pragma config(Motor,  port8,           driveR2,       tmotorVex393HighSpeed_MC29, openLoop)
#pragma config(Motor,  port9,           liftR,         tmotorVex393HighSpeed_MC29, openLoop)
#pragma config(Motor,  port10,          claw,          tmotorVex269_HBridge, openLoop)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

#include "Vex_Competition_Includes_Custom.c"

// Year-independent libraries

#include "motors.h"
#include "sensors.h"
#include "joysticks.h"
#include "cycle.h"
#include "utilities.h"
#include "pid.h"

#include "motors.c"
#include "sensors.c"
#include "joysticks.c"
#include "cycle.c"
#include "utilities.c"
#include "pid.c"

#include "controls.h"

sCycleData gMainCycle;

//#define MOBILE_LIFT_SAFETY

/* Drive */
void setDrive(word left, word right)
{
	gMotor[driveL1].power = gMotor[driveL2].power = left;
	gMotor[driveR1].power = gMotor[driveR2].power = right;
}

void handleDrive()
{
	word left = gJoy[JOY_THROTTLE].cur + gJoy[JOY_TURN].cur;
	word right = gJoy[JOY_THROTTLE].cur - gJoy[JOY_TURN].cur;
	velocityCheck(driveEncL);
	if (gSensor[driveEncL].velGood)
	{
		if (left > 10 && gSensor[driveEncL].velocity < 0) left = 10;
		else if (left < -10 && gSensor[driveEncL].velocity > 0) left = -10;
	}
	velocityCheck(driveEncR);
	if (gSensor[driveEncR].velGood)
	{
		if (right > 10 && gSensor[driveEncR].velocity < 0) right = 10;
		else if (right < -10 && gSensor[driveEncR].velocity > 0) right = -10;
	}
	setDrive(left, right);
}

void stack();
task stackAsync();

/* Lift */
typedef enum _sLiftStates {
	liftManaged,
	liftIdle,
	liftRaise,
	liftLower,
	liftRaiseBrk,
	liftLowerBrk,
	liftHold,
	liftAuto
} sLiftStates;

#define LIFT_UP_KP 2
#define LIFT_DOWN_KP 1.5

#define LIFT_BOTTOM 110
#define LIFT_TOP 4094

short gLiftTarget;
sLiftStates gLiftState = liftIdle;
unsigned long gLiftStart;

void setLift(word power)
{
	gMotor[liftL1].power = gMotor[liftL2].power = gMotor[liftR].power = power;
}

void handleLift()
{
	if (RISING(BTN_LIFT_UP))
	{
		stopTask(stackAsync);
		gLiftTarget = LIFT_TOP;
		gLiftState = liftRaise;
		gLiftStart = nPgmTime;
	}
	else if (FALLING(BTN_LIFT_UP))
	{
		stopTask(stackAsync);
		gLiftTarget = gSensor[liftPoti].value;
	}
	if (RISING(BTN_LIFT_DOWN))
	{
		stopTask(stackAsync);
		gLiftTarget = LIFT_BOTTOM;
		gLiftState = liftLower;
		gLiftStart = nPgmTime;
	}

	switch (gLiftState)
	{
		case liftRaise:
		{
			short error = gLiftTarget - gSensor[liftPoti].value;
			if (error <= 0 || gSensor[limTop].value)
			{
				velocityClear(liftPoti);
				setLift(-10);
				gLiftState = liftRaiseBrk;
			}
			else
			{
				float output = error * LIFT_UP_KP;
				if (output < 60) output = 60;
				setLift((word)output);
			}
			break;
		}
		case liftRaiseBrk:
		{
			velocityCheck(liftPoti);
			if (gSensor[liftPoti].velGood && gSensor[liftPoti].velocity <= 0)
			{
				gLiftState = liftHold;
				writeDebugStreamLine("Lift up %d", nPgmTime - gLiftStart);
			}
			break;
		}
		case liftLower:
		{
			short error = gLiftTarget - gSensor[liftPoti].value;
			if (error >= 0 || gSensor[limBottom].value)
			{
				velocityClear(liftPoti);
				setLift(10);
				gLiftState = liftLowerBrk;
			}
			else
			{
				float output = error * LIFT_DOWN_KP;
				if (output > -60) output = -60;
				setLift((word)output);
			}
			break;
		}
		case liftLowerBrk:
		{
			velocityCheck(liftPoti);
			if (gSensor[liftPoti].velGood && gSensor[liftPoti].velocity >= 0)
			{
				gLiftState = liftHold;
				writeDebugStreamLine("Lift down %d", nPgmTime - gLiftStart);
			}
			break;
		}
		case liftHold:
		{
			if (gSensor[limBottom].value)
				setLift(-10);
			else
				setLift(12);
			break;
		}
	}
}


/* Arm */
typedef enum _sArmStates {
	armManaged,
	armIdle,
	armPlainPID,
	armHold,
	armHorizontal
} sArmStates;

#define ARM_UP_KP 0.25
#define ARM_DOWN_KP 0.25
#define ARM_POSITIONS (ARR_LEN(gArmPositions) - 1)

#define ARM_TOP 2700
#define ARM_BOTTOM 650

short gArmPositions[] = { 630, 1250, 2700 };
word gArmHoldPower[] = { -12, 0, 5 };
short gArmPosition = 2;
short gArmTarget;
sArmStates gArmState = armIdle;
unsigned long gArmStart;
sPID gArmPID;

void setArm(word power)
{
	gMotor[arm].power = power;
}

void handleArm()
{
	if (RISING(BTN_ARM_UP))
	{
		stopTask(stackAsync);
		if (gArmPosition < ARM_POSITIONS)
		{
			gArmTarget = gArmPositions[++gArmPosition];
			gArmState = gArmPosition == 1 ? armHorizontal : armPlainPID;
			gArmStart = nPgmTime;
			pidReset(gArmPID);
		}
	}
	if (RISING(BTN_ARM_DOWN))
	{
		stopTask(stackAsync);
		if (gArmPosition > 0)
		{
			gArmTarget = gArmPositions[--gArmPosition];
			gArmState = gArmPosition == 1 ? armHorizontal : armPlainPID;
			gArmStart = nPgmTime;
			pidReset(gArmPID);
		}
	}
	if (RISING(BTN_ARM_TOGGLE))
	{
		gArmTarget = gArmPositions[gArmPosition ? (gArmPosition = 0) : (gArmPosition = 2)];
		gArmState = armPlainPID;
		gArmStart = nPgmTime;
	}

	switch (gArmState)
	{
		case armPlainPID:
		{
			int value = gSensor[armPoti].value;
			if (gArmTarget >= ARM_TOP && value >= ARM_TOP)
			{
				writeDebugStreamLine("Arm raise: %d", nPgmTime - gArmStart);
				gArmState = armHold;
			}
			else if (gArmTarget <= ARM_BOTTOM && value <= ARM_BOTTOM)
			{
				writeDebugStreamLine("Arm lower: %d", nPgmTime - gArmStart);
				gArmState = armHold;
			}
			else
			{
				pidCalculate(gArmPID, (float)gArmTarget, (float)value);
				setArm((word)gArmPID.output);
			}
			break;
		}
		case armHold:
		{
			setArm(gArmHoldPower[gArmPosition]);
			break;
		}
		case armHorizontal:
		{
			int value = gSensor[armPoti].value;
			if (abs(gArmTarget - value) < 400)
			{
				velocityCheck(armPoti);
				if (gSensor[armPoti].velGood)
				{
					int power = 10 - gSensor[armPoti].velocity / 2;
					setArm(LIM_TO_VAL(power, 15));
				}
			}
			else if (value > gArmTarget) setArm(-127);
			else setArm(127);
			break;
		}
	}
}


/* Claw */

typedef enum _sClawStates {
	clawManaged,
	clawIdle,
	clawOpening,
	clawClosing,
	clawOpened,
	clawClosed
} sClawStates;

#define CLAW_CLOSE_POWER 127
#define CLAW_OPEN_POWER -127
#define CLAW_CLOSE_HOLD_POWER 15
#define CLAW_OPEN_HOLD_POWER -5

#define CLAW_OPEN 1200
#define CLAW_CLOSE 800

#define CLAW_CLOSE_TIME 600

sClawStates gClawState = clawIdle;
unsigned long gClawStart;

void setClaw(word power)
{
	gMotor[claw].power = power;
}

void handleClaw()
{
	if (RISING(BTN_CLAW))
	{
		if (gClawState == clawClosed || gClawState == clawClosing)
		{
			gClawState = clawOpening;
			setClaw(CLAW_OPEN_POWER);
		}
		else
		{
			gClawState = clawClosing;
			setClaw(CLAW_CLOSE_POWER);
			gClawStart = nPgmTime;
		}
	}

	switch (gClawState)
	{
		case clawIdle:
		{
			setClaw(0);
			break;
		}
		case clawOpening:
		{
			if (gSensor[clawPoti].value >= CLAW_OPEN) gClawState = clawOpened;
			break;
		}
		case clawClosing:
		{
			if (nPgmTime - gClawStart >= 600) gClawState = clawClosed;
			break;
		}
		case clawOpened:
		{
			setClaw(CLAW_OPEN_HOLD_POWER);
			break;
		}
		case clawClosed:
		{
			setClaw(CLAW_CLOSE_HOLD_POWER);
			break;
		}
	}
}


/* Mobile Goal */

typedef enum _sMobileStates {
	mobileManaged,
	mobileIdle,
	mobileRaise,
	mobileLower,
	mobileHold
} sMobileStates;

#define MOBILE_TOP 2950
#define MOBILE_BOTTOM 600
#define MOBILE_20 1000

#define MOBILE_UP_POWER 127
#define MOBILE_DOWN_POWER -127
#define MOBILE_UP_HOLD_POWER 10
#define MOBILE_DOWN_HOLD_POWER -10

short gMobileTarget;
word gMobileHoldPower;
sMobileStates gMobileState = mobileIdle;

void setMobile(word power)
{
	gMotor[mobile].power = power;
}

void handleMobile()
{
#ifdef MOBILE_LIFT_SAFETY
	if (gSensor[liftPoti].value > 2200)
	{
#endif
		if (RISING(BTN_MOBILE_UP))
		{
			gMobileTarget = MOBILE_TOP;
			gMobileState = mobileRaise;
			gMobileHoldPower = MOBILE_UP_HOLD_POWER;
			setMobile(MOBILE_UP_POWER);
		}
		if (RISING(BTN_MOBILE_DOWN))
		{
			gMobileTarget = MOBILE_BOTTOM;
			gMobileState = mobileLower;
			gMobileHoldPower = MOBILE_DOWN_HOLD_POWER;
			setMobile(MOBILE_DOWN_POWER);
		}
#ifdef MOBILE_LIFT_SAFETY
	}
#endif

	switch (gMobileState)
	{
		case mobileRaise:
		{
			if (gSensor[mobilePoti].value >= gMobileTarget) gMobileState = mobileHold;
			break;
		}
		case mobileLower:
		{
			if (gSensor[mobilePoti].value <= gMobileTarget) gMobileState = mobileHold;
			break;
		}
		case mobileHold:
		{
			setMobile(gMobileHoldPower);
			break;
		}
		case mobileIdle:
		{
			setMobile(0);
			break;
		}
	}
}


/* Macros */

task armPID()
{
	while (true)
	{
		pidCalculate(gArmPID, (float)gArmPositions[1], (float)gSensor[armPoti].value);
		setArm((word)gArmPID.output);
		sleep(10);
	}
}

int gNumCones = 0;
const int gStackPos[11] = { 0, 0, 0, 150, 320, 510, 720, 950, 1200, 1470, 1760 };
const int gScanPos[11] = {0, 0, 150, 320, 510, 720, 950, 1200, 1470, 1760, 2070 };

bool gMacros[20] = { false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false };

void scanStack()
{
	gLiftState = liftManaged;
	gArmState = armManaged;
	gArmPosition = gArmPositions[gArmPosition = 1];
	pidReset(gArmPID);
	startTask(armPID);
	while (abs(gSensor[armPoti].value - gArmTarget) > 20) sleep(10);
	setLift(-80);
	int acc = 0;
	while (acc < 10 && !gSensor[limTop].value)
	{
		if (gSensor[liftPoti].value <= LIFT_BOTTOM)
		{
			gNumCones = 0;
			goto end;
		}
		if (gSensor[armSonic].value) acc = 0;
		else ++acc;
		sleep(10);
	}
	int pos = gSensor[liftPoti].value - LIFT_BOTTOM;
	gNumCones = 11;
	for (int i = 0; i < ARR_LEN(gScanPos); i++)
	{
		if (gScanPos[i] >= pos)
		{
			gNumCones = i - 1;
			break;
		}
	}
	setLift(-127);
	while (gSensor[liftPoti].value > LIFT_BOTTOM) sleep(10);
	end:
	stopTask(armPID);
	gLiftState = liftHold;
	gArmState = armHold;
}

task scanStackAsync()
{
	gMacros[scanStackAsync] = true;
	scanStack();
	gMacros[scanStackAsync] = false;
}

void stack()
{
	gArmState = armManaged;
	gClawState = clawManaged;
	//TODO: take into account number of cones, raise appropriately
	gArmTarget = gArmPositions[gArmPosition = 2];
	startTask(armPID);
	while (gSensor[armPoti].value < gArmTarget) sleep(10);
	writeDebugStreamLine("Raised %d %d", nPgmTime, gSensor[armPoti].value);
	sleep(500);
	setClaw(CLAW_OPEN_POWER);
	while (gSensor[clawPoti].value > CLAW_CLOSE) sleep(10);
	writeDebugStreamLine("Done %d", nPgmTime);
	++gNumCones;
	stopTask(armPID);
	gArmState = armHold;
	gClawState = clawOpened;
}

task stackAsync()
{
	gMacros[stackAsync] = true;
	stack();
	gMacros[stackAsync] = false;
}

void stackFromLoader()
{
	gArmState = armManaged;
	gClawState = clawManaged;
	gArmTarget = gArmPositions[gArmPosition = 1];
	pidReset(gArmPID);
	startTask(armPID);
	setClaw(CLAW_OPEN_POWER);
	while (abs(gSensor[armPoti].value - gArmTarget) > 20) sleep(10);
	writeDebugStreamLine("Arm at horizontal %d %d", nPgmTime, gSensor[armPoti].value);
	sleep(100);
	setClaw(CLAW_CLOSE_POWER);
	sleep(CLAW_CLOSE_TIME);
	setClaw(CLAW_CLOSE_HOLD_POWER);
	writeDebugStreamLine("Grabbed cone %d", nPgmTime);
	sleep(100);
	stack();
}

task stackFromLoaderAsync()
{
	gMacros[stackFromLoaderAsync] = true;
	stackFromLoader();
	gMacros[stackFromLoaderAsync] = false;
}

#define OFFSET_20_ZONE_P1 700
#define OFFSET_20_ZONE_P2 850

void alignAndScore20()
{
	//TODO: Raise lift and arm above stack
	while (gMotor[driveL1].power > 0 || gMotor[driveR1].power > 0)
	{
		setDrive(gSensor[leftLine].value ? -10 : 50, gSensor[rightLine].value ? -10 : 50);
		sleep(10);
	}
	sleep(100);
	setDrive(127, 127);
	int initial = gSensor[driveEncL].value;
	while (gSensor[driveEncL].value < initial + OFFSET_20_ZONE_P1) sleep(10);
	gMobileState = mobileManaged;
	setMobile(MOBILE_DOWN_POWER);
	while (gSensor[driveEncL].value < initial + OFFSET_20_ZONE_P2)
	{
		if (gSensor[mobilePoti].value < MOBILE_20) setMobile(12);
		sleep(10);
	}
	setDrive(-10, -10);
	while (gSensor[mobilePoti].value >= MOBILE_20) sleep(10);
	setMobile(12);
	sleep(200);
	setDrive(-127, -127);
	setMobile(MOBILE_DOWN_POWER);
	while (gSensor[driveEncL].value > initial)
	{
		if (gSensor[mobilePoti].value <= gMobileTarget) setMobile(MOBILE_DOWN_HOLD_POWER);
		sleep(10);
	}
	setDrive(0, 0);
	while (gSensor[mobilePoti].value > gMobileTarget) sleep(10);
	setMobile(gMobileHoldPower = MOBILE_DOWN_HOLD_POWER);
	gMobileState = mobileHold;
}

task alignAndScore20Async()
{
	gMacros[alignAndScore20Async] = true;
	alignAndScore20();
	gMacros[alignAndScore20Async] = false;
}

void handleMacros()
{
	/*if (RISING(BTN_MACRO_SCAN))
	{
		startTask(scanStackAsync);
	}
	if (RISING(BTN_MACRO_20))
	{
		if (gMacros[alignAndScore20Async])
		{
			stopTask(alignAndScore20Async);
			gMotors[alignAndScore20Async] = false;
		}
		else startTask(alignAndScore20Async);
	}
	if (RISING(BTN_MACRO_STACK))
	{
		if (gMacros[stackAsync])
		{
			stopTask(stackAsync);
			gMotors[stackAsync] = false;
		}
		else startTask(stackAsync);
	}*/
	if (RISING(BTN_MACRO_LOADER))
	{
		if (gMacros[stackFromLoaderAsync])
		{
			stopTask(stackFromLoaderAsync);
			gMacros[stackFromLoaderAsync] = false;
		}
		else startTask(stackFromLoaderAsync);
	}
}


/* LCD */

void handleLcd()
{
	string line;

	sprintf(line, "%4d %4d", gSensor[driveEncL].value, gSensor[driveEncR].value);
	clearLCDLine(0);
	displayLCDString(0, 0, line);

	velocityCheck(driveEncL);
	velocityCheck(driveEncR);

	sprintf(line, "%2.1f %2.1f", gSensor[driveEncL].velocity, gSensor[driveEncR].velocity);
	clearLCDLine(1);
	displayLCDString(1, 0, line);
}

// This function gets called 2 seconds after power on of the cortex and is the first bit of code that is run
void startup()
{
	clearDebugStream();

	// Setup and initilize the necessary libraries
	setupMotors();
	setupSensors();
	setupJoysticks();

	setupDgtIn(leftLine, 0, 150);
	setupDgtIn(rightLine, 0, 150);
	setupDgtIn(armSonic, 20, 200);

	velocityClear(driveEncL);
	velocityClear(driveEncR);

	gJoy[JOY_TURN].deadzone = DZ_TURN;
	gJoy[JOY_THROTTLE].deadzone = DZ_THROTTLE;

	pidInit(gArmPID, 0.2, 0.001, 0.0, 70, 150, 5, 127);
}

// This function gets called every 25ms during disabled (DO NOT PUT BLOCKING CODE IN HERE)
void disabled()
{
	handleLcd();
}

// This task gets started at the begining of the autonomous period
task autonomous()
{
	startSensors(); // Initilize the sensors
}

// This task gets started at the beginning of the usercontrol period
task usercontrol()
{
	startSensors(); // Initilize the sensors
	initCycle(gMainCycle, 10);

	while (true)
	{
		updateSensorInputs();
		updateJoysticks();

		handleDrive();
		handleLift();
		handleArm();
		handleClaw();
		handleMobile();
		handleMacros();

		handleLcd();

		updateSensorOutputs();
		updateMotors();
		endCycle(gMainCycle);
	}
}
