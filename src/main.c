#pragma config(Sensor, in1,    autoPoti,       sensorPotentiometer)
#pragma config(Sensor, in2,    mobilePoti,     sensorPotentiometer)
#pragma config(Sensor, in3,    liftPoti,       sensorPotentiometer)
#pragma config(Sensor, in4,    armPoti,        sensorPotentiometer)
#pragma config(Sensor, in5,    limLift,         sensorAnalog)
#pragma config(Sensor, in6,    lsBarL,         sensorReflection)
#pragma config(Sensor, in7,    lsBarR,         sensorReflection)
#pragma config(Sensor, in8,    lsMobile,       sensorReflection)
#pragma config(Sensor, dgtl1,  trackL,         sensorQuadEncoder)
#pragma config(Sensor, dgtl3,  trackR,         sensorQuadEncoder)
#pragma config(Sensor, dgtl5,  trackB,         sensorQuadEncoder)
#pragma config(Sensor, dgtl7,  sonarL,         sensorSONAR_mm)
#pragma config(Sensor, dgtl9,  limArm,         sensorTouch)
#pragma config(Sensor, dgtl10, jmpSkills,      sensorDigitalIn)
#pragma config(Sensor, dgtl11, sonarR,         sensorSONAR_mm)
#pragma config(Motor,  port2,           liftR,         tmotorVex393HighSpeed_MC29, openLoop)
#pragma config(Motor,  port3,           driveL1,       tmotorVex393TurboSpeed_MC29, openLoop, reversed)
#pragma config(Motor,  port4,           driveL2,       tmotorVex393TurboSpeed_MC29, openLoop)
#pragma config(Motor,  port5,           arm,           tmotorVex393HighSpeed_MC29, openLoop, reversed)
#pragma config(Motor,  port6,           mobile,        tmotorVex393HighSpeed_MC29, openLoop)
#pragma config(Motor,  port7,           driveR2,       tmotorVex393TurboSpeed_MC29, openLoop, reversed)
#pragma config(Motor,  port8,           driveR1,       tmotorVex393TurboSpeed_MC29, openLoop)
#pragma config(Motor,  port9,           liftL,         tmotorVex393HighSpeed_MC29, openLoop, reversed)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

#define CHECK_POTI_JUMPS 1
#define DRIVE_TURN (gJoy[JOY_TURN].cur - gJoy[JOY_TURN].deadzone * sgn(gJoy[JOY_TURN].cur))

// Year-independent libraries (headers)
#include "task.h"
#include "motors.h"
#include "sensors.h"
#include "joysticks.h"
#include "cycle.h"
#include "utilities.h"

// Year-independent libraries (source)
#include "task.c"
#include "motors.c"
#include "sensors.c"
#include "joysticks.c"
#include "cycle.c"
#include "utilities.c"

// Other includes
#include "Vex_Competition_Includes_Custom.c"

#include "controls.h"

/* Drive Controls */
void handleDrive()
{
	gMotor[driveL1].power = gMotor[driveL2].power = LIM_TO_VAL((gJoy[JOY_THROTTLE].cur + DRIVE_TURN), 127);
	gMotor[driveR1].power = gMotor[driveR2].power = LIM_TO_VAL((gJoy[JOY_THROTTLE].cur - DRIVE_TURN), 127);

	if (!gJoy[JOY_THROTTLE}.cur && !gJoy[JOY_TURN].cur )
{
	velocityCheck(trackL);
	velocityCheck(trackR);
	//writeDebugStreamLine("L: %d, r: %d", gSensor[trackL].velocity, gSensor[trackR].velocity);
	if (gSensor[trackL].velocity > 0.3)
		gMotor[driveL1].power = gMotor[driveL2].power  = LIM_TO_VAL(sgn(gSensor[trackL].velocity) * -8, 15);
	if (gSensor[trackR].velocity > 0.3)
		gMotor[driveR1].power = gMotor[driveR2].power  = LIM_TO_VAL(sgn(gSensor[trackR].velocity) * -8, 15);
}
}

/* Lift Controls */
#define LIFT_BOTTOM 800 //1100
#define LIFT_TOP (LIFT_BOTTOM + 1930)
#define LIFT_MID (LIFT_BOTTOM + 620)
#define LIFT_HOLD_DOWN_THRESHOLD (LIFT_BOTTOM + 50)
#define LIFT_HOLD_UP_THRESHOLD (LIFT_TOP - 100)

void setLift(word val)
{
	gMotor[liftR].power = gMotor[liftL].power = LIM_TO_VAL(val, 127);
}

typedef enum _tLiftStates
{
	idle = 0,
	hold,
	move
} tLiftStates;

tLiftStates gLiftState = idle;

void setLiftState(tLiftStates state, word val = 0)
{
	gLiftState = state;
	switch (gLiftState)
	{
	case 0: //idle
		{
			setLift(0);
			break;
		}
	case 1: //hold
		{
			if (gSensor[liftPoti].value < LIFT_HOLD_DOWN_THRESHOLD) //Lift is at bottom
				setLift(!gSensor[limLift].value ? -15 : -90);
			else if (gSensor[liftPoti].value > LIFT_HOLD_UP_THRESHOLD) //Lift is at top
				setLift(gSensor[liftPoti].value >= LIFT_TOP ? 15 : 127);
			else //Lift is in middle
				setLift(gSensor[liftPoti].value > LIFT_MID ? 12 : 10);
			break;
		}
	case 2: //move
		{
			setLift(val);
			break;
		}
	}
}


void handleLift() //Decide which state to put machine in
{
	//writeDebugStreamLine("State = %d, Lift loc = %d, Lift Power = %d", gLiftState, gSensor[liftPoti].value, gMotor[liftR].power);

	word joy = gJoy[JOY_LIFT].cur;
	if (!joy || abs(gJoy[JOY_LIFT].cur) < abs(gJoy[JOY_LIFT].lst))
	{
		setLiftState(hold);
	}
	else if (joy)
	{
		if ((sgn(joy) == -1 && gSensor[liftPoti].value < LIFT_HOLD_DOWN_THRESHOLD) || (sgn(joy) == 1 && gSensor[liftPoti].value > LIFT_HOLD_UP_THRESHOLD))
			setLiftState(hold);
		else
			setLiftState(move, joy);
	}
}

/* Mobile Goal Controls */
#define MOBILE_TOP 2440
#define MOBILE_BOTTOM 950
#define MOBILE_MIDDLE_UP 1150
#define MOBILE_MIDDLE_DOWN 1550
#define MOBILE_MIDDLE_THRESHOLD 2250
#define MOBILE_HALFWAY 1550

#define MOBILE_UP_HOLD_POWER 12
#define MOBILE_DOWN_HOLD_POWER -15

typedef enum _tMobileStates
{
	idle,
	hold,
	moveTop,
	moveBottom,
	moveUpToMid,
	moveDownToMid,
	holdMid
}tMobileStates;

tMobileStates gMobileState = idle;

void setMobile(word val)
{
	gMotor[mobile].power = val;
}

void setMobileState()
{
	switch (gMobileState)
	{
		case 0: //idle
		{
			setMobile(0);
			break;
		}
		case 1: //hold
		{
			setMobile(gSensor[mobilePoti].value < MOBILE_HALFWAY? -15 : 12);
			break;
		}
		case 2: //moveTop
		{
			setMobile(127);
			if (gSensor[mobilePoti].value > (MOBILE_TOP - 50))
				gMobileState = hold;
			break;
		}
		case 3: //moveBottom
		{
			setMobile(-127);
			if (gSensor[mobilePoti].value < (MOBILE_BOTTOM + 50))
				gMobileState = hold;
			break;
		}
		case 4: //moveUpToMid
		{
			setMobile(127);
			if (gSensor[mobilePoti].value > MOBILE_MIDDLE_UP)
				gMobileState = holdMid;
			break;
		}
		case 5: //moveDownToMid
		{
			setMobile(-127);
			if (gSensor[mobilePoti].value < MOBILE_MIDDLE_DOWN)
				gMobileState = holdMid;
			break;
		}
		case 5: //holdMid
		{
			setMobile(10);
			break;
		}
	}
}

void handleMobile()
{
	if (RISING(BTN_MOBILE_TOGGLE))
	{
		writeDebugStreamLine("Toggle Mobile");
		if (gMobileState != holdMid)
		{
			gMobileState = (gSensor[mobilePoti].value < MOBILE_HALFWAY)? moveTop : moveBottom;
			writeDebugStreamLine("Mobile state: %d", gMobileState);
		}
	}
	if (RISING(BTN_MOBILE_MIDDLE))
	{
		gMobileState = (gSensor[mobilePoti].value < MOBILE_HALFWAY)? moveUpToMid : moveDownToMid;
	}
}

void startup()
{
clearDebugStream();
setupSensors();
setupMotors();
setupJoysticks();
tInit();

//Setup Joysticks.Buttons
enableJoystick(JOY_THROTTLE);
enableJoystick(JOY_TURN);
enableJoystick(JOY_LIFT);
enableJoystick(BTN_MOBILE_TOGGLE);
enableJoystick(BTN_MOBILE_MIDDLE);
MIRROR(BTN_MOBILE_TOGGLE);
MIRROR(BTN_MOBILE_MIDDLE);

gJoy[JOY_THROTTLE].deadzone = 15;
gJoy[JOY_TURN].deadzone = 15;
gJoy[JOY_LIFT].deadzone = 5;
}

void disabled()
{
updateSensorInputs();
//selectAuto();
//handleLcd();
}

task autonomous()
{
sCycleData cycle;
initCycle(cycle, 10, "autonomous");

	while(true)
	{
		endCycle(cycle);
	}
}

task usercontrol()
{
sCycleData cycle;
initCycle(cycle, 10, "usercontrol");

while (true)
{
	updateJoysticks();
	updateMotors();
	updateSensorInputs();
	updateSensorOutputs();

	handleDrive();
	handleLift();
	handleMobile();

	setMobileState();

	endCycle(cycle);
}
}
