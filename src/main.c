#pragma config(Sensor, in1,    autoPoti,       sensorPotentiometer)
#pragma config(Sensor, in2,    mobilePoti,     sensorPotentiometer)
#pragma config(Sensor, in3,    liftPoti,       sensorPotentiometer)
#pragma config(Sensor, in4,    armPoti,        sensorPotentiometer)
#pragma config(Sensor, in5,    clawPoti,       sensorPotentiometer)
#pragma config(Sensor, in6,    expander,       sensorAnalog)
#pragma config(Sensor, in7,    leftLine,       sensorLineFollower)
#pragma config(Sensor, in8,    rightLine,      sensorLineFollower)
#pragma config(Sensor, dgtl1,  armSonic,       sensorSONAR_mm)
#pragma config(Sensor, dgtl3,  limBottom,      sensorTouch)
#pragma config(Sensor, dgtl4,  limTop,         sensorTouch)
#pragma config(Sensor, dgtl5,  driveEncL,      sensorQuadEncoder)
#pragma config(Sensor, dgtl7,  driveEncR,      sensorQuadEncoder)
#pragma config(Sensor, dgtl9,  latEnc,         sensorQuadEncoder)
#pragma config(Sensor, dgtl11, frontSonic,     sensorSONAR_mm)
#pragma config(Motor,  port1,           arm,           tmotorVex393_HBridge, openLoop)
#pragma config(Motor,  port2,           liftL1,        tmotorVex393HighSpeed_MC29, openLoop, reversed)
#pragma config(Motor,  port3,           driveL1,       tmotorVex393HighSpeed_MC29, openLoop)
#pragma config(Motor,  port4,           driveL2,       tmotorVex393HighSpeed_MC29, openLoop, reversed)
#pragma config(Motor,  port5,           liftL2,        tmotorVex393HighSpeed_MC29, openLoop, reversed)
#pragma config(Motor,  port6,           mobile,        tmotorVex393HighSpeed_MC29, openLoop)
#pragma config(Motor,  port7,           driveR1,       tmotorVex393HighSpeed_MC29, openLoop, reversed)
#pragma config(Motor,  port8,           driveR2,       tmotorVex393HighSpeed_MC29, openLoop)
#pragma config(Motor,  port9,           liftR,         tmotorVex393HighSpeed_MC29, openLoop)
#pragma config(Motor,  port10,          claw,          tmotorVex393HighSpeed_HBridge, openLoop)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

#include "Vex_Competition_Includes_Custom.c"

// Year-independent libraries

#include "motors.h"
#include "sensors.h"
#include "joysticks.h"
#include "cycle.h"
#include "utilities.h"
#include "pid.h"

#include "motors.c"
#include "sensors.c"
#include "joysticks.c"
#include "cycle.c"
#include "utilities.c"
#include "pid.c"

#include "controls.h"

sCycleData gMainCycle;
int gNumCones = 0;

/* Drive */
void setDrive(word left, word right)
{
	gMotor[driveL1].power = gMotor[driveL2].power = left;
	gMotor[driveR1].power = gMotor[driveR2].power = right;
}

void handleDrive()
{
	setDrive(gJoy[JOY_THROTTLE].cur + gJoy[JOY_TURN].cur / 2, gJoy[JOY_THROTTLE].cur - gJoy[JOY_TURN].cur / 2);
}

void stack();
task stackAsync();

/* Lift */
typedef enum _sLiftStates {
	liftManaged,
	liftIdle,
	//liftRaise,
	//liftLower,
	//liftRaiseBrk,
	//liftLowerBrk,
	liftManual,
	liftHold,
	liftAuto
} sLiftStates;

#define LIFT_UP_KP 2
#define LIFT_DOWN_KP 1.5

#define LIFT_BOTTOM 110
#define LIFT_TOP 4094

short gLiftTarget;
sLiftStates gLiftState = liftIdle;
unsigned long gLiftStart;

void setLift(word power)
{
	gMotor[liftL1].power = gMotor[liftL2].power = gMotor[liftR].power = power;
}

void handleLift()
{
	//if (RISING(BTN_LIFT_UP))
	//{
	//	stopTask(stackAsync);
	//	gLiftTarget = LIFT_TOP;
	//	gLiftState = liftRaise;
	//	gLiftStart = nPgmTime;
	//}
	//else if (FALLING(BTN_LIFT_UP))
	//{
	//	stopTask(stackAsync);
	//	gLiftTarget = gSensor[liftPoti].value;
	//}
	//if (RISING(BTN_LIFT_DOWN))
	//{
	//	stopTask(stackAsync);
	//	gLiftTarget = LIFT_BOTTOM;
	//	gLiftState = liftLower;
	//	gLiftStart = nPgmTime;
	//}
	if (RISING(JOY_LIFT))
	{
		gLiftState = liftManual;
	}
	if (FALLING(JOY_LIFT))
	{
		gLiftState = liftHold;
	}

	switch (gLiftState)
	{
		//case liftRaise:
		//{
		//	short error = gLiftTarget - gSensor[liftPoti].value;
		//	if (error <= 0 || gSensor[limTop].value)
		//	{
		//		velocityClear(liftPoti);
		//		setLift(-10);
		//		gLiftState = liftRaiseBrk;
		//	}
		//	else
		//	{
		//		float output = error * LIFT_UP_KP;
		//		if (output < 60) output = 60;
		//		setLift((word)output);
		//	}
		//	break;
		//}
		//case liftRaiseBrk:
		//{
		//	velocityCheck(liftPoti);
		//	if (gSensor[liftPoti].velGood && gSensor[liftPoti].velocity <= 0)
		//	{
		//		gLiftState = liftHold;
		//		writeDebugStreamLine("Lift up %d", nPgmTime - gLiftStart);
		//	}
		//	break;
		//}
		//case liftLower:
		//{
		//	short error = gLiftTarget - gSensor[liftPoti].value;
		//	if (error >= 0 || gSensor[limBottom].value)
		//	{
		//		velocityClear(liftPoti);
		//		setLift(10);
		//		gLiftState = liftLowerBrk;
		//	}
		//	else
		//	{
		//		float output = error * LIFT_DOWN_KP;
		//		if (output > -60) output = -60;
		//		setLift((word)output);
		//	}
		//	break;
		//}
		//case liftLowerBrk:
		//{
		//	velocityCheck(liftPoti);
		//	if (gSensor[liftPoti].velGood && gSensor[liftPoti].velocity >= 0)
		//	{
		//		gLiftState = liftHold;
		//		writeDebugStreamLine("Lift down %d", nPgmTime - gLiftStart);
		//	}
		//	break;
		//}
		case liftManual:
		{
			word value = gJoy[JOY_LIFT].cur * 2 - 128 * sgn(gJoy[JOY_LIFT].cur);
			if (gSensor[limBottom].value && value < -10) value = -10;
			if (gSensor[limTop].value && value > 10) value = 10;
			setLift(value);
			break;
		}
		case liftHold:
		{
			if (gSensor[liftPoti] < 10)
				setLift(-10);
			else
				setLift(12);
			break;
		}
		case liftIdle:
		{
			setLift(0);
			break;
		}
	}
}


/* Arm */
typedef enum _sArmStates {
	armManaged,
	armIdle,
	armManual,
	armPlainPID,
	armRaise,
	armLower,
	armHold,
	armHorizontal
} sArmStates;

#define ARM_UP_KP 0.25
#define ARM_DOWN_KP 0.25
#define ARM_POSITIONS (ARR_LEN(gArmPositions) - 1)

#define ARM_TOP 2700
#define ARM_BOTTOM 650

short gArmPositions[] = { 680, 1300, 2700 };
word gArmHoldPower[] = { -12, 0, 5 };
short gArmPosition = 2;
short gArmTarget;
sArmStates gArmState = armIdle;
unsigned long gArmStart;
sPID gArmPID;
sPID* gArmPIDInUse = &gArmPID;

void setArm(word power)
{
	writeDebugStreamLine("Arm %d %d", nPgmTime, power);
	gMotor[arm].power = power;
}

void handleArm()
{
	if (RISING(JOY_ARM))
	{
		gArmState = armManual;
	}
	if (FALLING(JOY_ARM) && gArmState == armManual)
	{
		if (gSensor[armPoti].value <= ARM_BOTTOM) gArmPosition = 0;
		else if (gSensor[armPoti].value >= ARM_TOP) gArmPosition = 2;
		else gArmPosition = 1;
		gArmState = armHold;
	}
	if (RISING(BTN_ARM_TOGGLE))
	{
		gArmState = gArmTarget > gArmPositions[1] ? armLower : armRaise;
		gArmTarget = gArmPositions[gArmTarget > gArmPositions[1] ? (gArmPosition = 0) : (gArmPosition = 2)];
		gArmStart = nPgmTime;
	}

	switch (gArmState)
	{
		case armManual:
		{
			word value = gJoy[JOY_ARM].cur * 2 - 128 * sgn(gJoy[JOY_ARM].cur);
			if (gSensor[armPoti].value >= ARM_TOP && value > 10) value = 10;
			if (gSensor[armPoti].value <= ARM_BOTTOM && value < -10) value = -10;
			setArm(value);
			break;
		}
		case armPlainPID:
		{
			int value = gSensor[armPoti].value;
			if (gArmTarget >= ARM_TOP && value >= ARM_TOP)
			{
				writeDebugStreamLine("Arm raise: %d", nPgmTime - gArmStart);
				gArmState = armHold;
			}
			else if (gArmTarget <= ARM_BOTTOM && value <= ARM_BOTTOM)
			{
				writeDebugStreamLine("Arm lower: %d", nPgmTime - gArmStart);
				gArmState = armHold;
			}
			else
			{
				pidCalculate(gArmPID, (float)gArmTarget, (float)value);
				setArm((word)gArmPID.output);
			}
			break;
		}
		case armRaise:
		{
			if (gSensor[armPoti].value >= gArmTarget)
			{
				writeDebugStreamLine("Arm raise: %d", nPgmTime - gArmStart);
				gArmState = armHold;
			}
			else setArm(127);
			break;
		}
		case armLower:
		{
			if (gSensor[armPoti].value <= gArmTarget)
			{
				writeDebugStreamLine("Arm lower: %d", nPgmTime - gArmStart);
				gArmState = armHold;
			}
			else setArm(-127);
			break;
		}
		case armHold:
		{
			setArm(gArmPosition == 1 ? gSensor[armPoti].value < 1700 ? 15 : 9 : gArmHoldPower[gArmPosition]);
			break;
		}
		case armHorizontal:
		{
			int value = gSensor[armPoti].value;
			if (abs(gArmTarget - value) < 400)
			{
				velocityCheck(armPoti);
				if (gSensor[armPoti].velGood)
				{
					int power = 10 - gSensor[armPoti].velocity / 2;
					setArm(LIM_TO_VAL(power, 15));
				}
			}
			else if (value > gArmTarget) setArm(-127);
			else setArm(127);
			break;
		}
	}
}


/* Claw */

typedef enum _sClawStates {
	clawManaged,
	clawIdle,
	clawOpening,
	clawClosing,
	clawOpened,
	clawClosed
} sClawStates;

#define CLAW_CLOSE_POWER 127
#define CLAW_OPEN_POWER -127
#define CLAW_CLOSE_HOLD_POWER 15
#define CLAW_OPEN_HOLD_POWER -5

#define CLAW_OPEN 1100
#define CLAW_CLOSE 950

#define CLAW_TIMEOUT 1000

sClawStates gClawState = clawIdle;
unsigned long gClawStart;

void setClaw(word power)
{
	gMotor[claw].power = power;
}

void handleClaw()
{
	if (RISING(BTN_CLAW))
	{
		if (gClawState == clawClosed || gClawState == clawClosing)
		{
			gClawState = clawOpening;
			setClaw(CLAW_OPEN_POWER);
		}
		else
		{
			gClawState = clawClosing;
			setClaw(CLAW_CLOSE_POWER);
		}
		gClawStart = nPgmTime;
	}

	switch (gClawState)
	{
		case clawIdle:
		{
			setClaw(0);
			break;
		}
		case clawOpening:
		{
			if (gSensor[clawPoti].value >= CLAW_OPEN && nPgmTime - gClawStart < CLAW_TIMEOUT) gClawState = clawOpened;
			break;
		}
		case clawClosing:
		{
			if (gSensor[clawPoti].value <= CLAW_CLOSE && nPgmTime - gClawStart < CLAW_TIMEOUT) gClawState = clawClosed;
			break;
		}
		case clawOpened:
		{
			setClaw(CLAW_OPEN_HOLD_POWER);
			break;
		}
		case clawClosed:
		{
			setClaw(CLAW_CLOSE_HOLD_POWER);
			break;
		}
	}
}


/* Mobile Goal */

typedef enum _sMobileStates {
	mobileManaged,
	mobileIdle,
	mobileRaise,
	mobileLower,
	mobileHold,
	mobile20
} sMobileStates;

#define MOBILE_TOP 2950
#define MOBILE_BOTTOM 600
#define MOBILE_20 2200

#define MOBILE_UP_POWER 127
#define MOBILE_DOWN_POWER -127
#define MOBILE_UP_HOLD_POWER 10
#define MOBILE_DOWN_HOLD_POWER -10

short gMobileTarget;
word gMobileHoldPower;
sMobileStates gMobileState = mobileIdle;
sMobileStates gMobileNextState;
unsigned long gMobileStart;

void setMobile(word power)
{
	gMotor[mobile].power = power;
}

void handleMobile()
{
	if (RISING(BTN_MOBILE_UP))
	{
		gMobileTarget = MOBILE_TOP;
		gMobileState = mobileRaise;
		gMobileNextState = mobileHold;
		gMobileHoldPower = MOBILE_UP_HOLD_POWER;
		setMobile(MOBILE_UP_POWER);
	}
	if (RISING(BTN_MOBILE_DOWN))
	{
		gMobileTarget = MOBILE_BOTTOM;
		gMobileState = mobileLower;
		gMobileNextState = mobileHold;
		gMobileHoldPower = MOBILE_DOWN_HOLD_POWER;
		setMobile(MOBILE_DOWN_POWER);
	}
	if (RISING(BTN_MOBILE_20))
	{
		gMobileTarget = MOBILE_20;
		gMobileState = mobileLower;
		gMobileNextState = mobile20
		setMobile(MOBILE_DOWN_POWER);
	}

	switch (gMobileState)
	{
		case mobileRaise:
		{
			if (gSensor[mobilePoti].value >= gMobileTarget)
			{
				gMobileState = gMobileNextState;
				gMobileStart = nPgmTime;
			}
			break;
		}
		case mobileLower:
		{
			if (gSensor[mobilePoti].value <= gMobileTarget)
			{
				gMobileState = gMobileNextState;
				gMobileStart = nPgmTime;
				gNumCones = 0;
			}
			break;
		}
		case mobileHold:
		{
			setMobile(gMobileHoldPower);
			break;
		}
		case mobile20:
		{
			setMobile(nPgmTime - gMobileStart > 300 ? 10 : -5);
			break;
		}
		case mobileIdle:
		{
			setMobile(0);
			break;
		}
	}
}


/* Macros */

bool gLiftAsyncDone;

task liftDownAsync()
{
	gLiftAsyncDone = false;
	while (gSensor[liftPoti].value > gLiftTarget && !gSensor[limBottom].value) sleep(10);
	setLift(gLiftTarget > 10 ? 20 : -10);
	gLiftAsyncDone = true;
}

task liftUpAsync()
{
	gLiftAsyncDone = false;
	while (gSensor[liftPoti].value < gLiftTarget && !gSensor[limTop].value) sleep(10);
	setLift(gLiftTarget < 3900 ? -20 : 15);
	gLiftAsyncDone = true;
}

task armPID()
{
	while (true)
	{
		pidCalculate(*gArmPIDInUse, (float)gArmPositions[1], (float)gSensor[armPoti].value);
		setArm((word)gArmPIDInUse->output + 10);
		sleep(10);
	}
}

int gMaxLiftHeight;

task trackLift()
{
	gMaxLiftHeight = 0;
	while (true)
	{
		int value = gSensor[liftPoti].value;
		if (value > gMaxLiftHeight) gMaxLiftHeight = value;
		sleep(10);
	}
}

const int gStackPos[11] = { 0, 0, 0, -50, 200, 750, 1200, 1600, 2100, 2700, 3900 };
const int gStackDownPos[11] = { 0, 0, 0, -70, 0, 400, 800, 1300, 1700, 2400, 3200 };
const int gStackBackPos[11] = { 0, 0, 0, -50, 20, 500, 850, 1400, 1900, 2600, 0 };
const int gStackDelayPos[11] = { 0, 0, 0, 0, 50, 400, 550, 800, 1000, 1300, 2300 };
const int gStackHoldPower[11] = {0, 0, 0, 0, 20, 20, 20, 20, 20, 20, 20 };
const int gScanPos[11] = {0, 0, 150, 320, 590, 780, 950, 1200, 1470, 1760, 2070 };

bool gMacros[20] = { false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false };

void scanStack()
{
	gLiftState = liftManaged;
	gArmState = armManaged;
	gArmPosition = gArmPositions[gArmPosition = 1];
	pidReset(gArmPID);
	startTask(armPID);
	while (abs(gSensor[armPoti].value - gArmTarget) > 20) sleep(10);
	setLift(-80);
	int acc = 0;
	while (acc < 10 && !gSensor[limTop].value)
	{
		if (gSensor[liftPoti].value <= LIFT_BOTTOM)
		{
			gNumCones = 0;
			goto end;
		}
		if (gSensor[armSonic].value) acc = 0;
		else ++acc;
		sleep(10);
	}
	int pos = gSensor[liftPoti].value - LIFT_BOTTOM;
	gNumCones = 11;
	for (int i = 0; i < ARR_LEN(gScanPos); i++)
	{
		if (gScanPos[i] >= pos)
		{
			gNumCones = i - 1;
			break;
		}
	}
	setLift(-127);
	while (gSensor[liftPoti].value > LIFT_BOTTOM) sleep(10);
	end:
	stopTask(armPID);
	gLiftState = liftHold;
	gArmState = armHold;
}

task scanStackAsync()
{
	gMacros[scanStackAsync] = true;
	scanStack();
	gMacros[scanStackAsync] = false;
}

void stackInternal()
{
	setClaw(CLAW_CLOSE_POWER);
	unsigned long time = nPgmTime;
	while (gSensor[clawPoti].value > CLAW_CLOSE && nPgmTime - time < CLAW_TIMEOUT) sleep(10);
	sleep(100);
	setClaw(CLAW_CLOSE_HOLD_POWER);
	writeDebugStreamLine("Grabbed %d", nPgmTime);
	setArm(127);
	while (gSensor[armPoti].value < 850) sleep(10);
	if (gNumCones >= 2)
	{
		gLiftTarget = LIFT_BOTTOM + gStackPos[gNumCones];
		gLiftAsyncDone = false;
		setLift(gNumCones == 2 ? 60 : 127);
		startTask(liftUpAsync);
		if (gNumCones >= 5)
		{
			setArm(10);
			while (gSensor[liftPoti].value < LIFT_BOTTOM + gStackDelayPos[gNumCones]) sleep(10);
			setArm(127);
		}
	}
	gArmTarget = gArmPositions[gArmPosition = 2];
	if (gNumCones < 3)
	{
		while (gSensor[armPoti].value < 2100) sleep(10);
		writeDebugStreamLine("Braking %d", nPgmTime);
		setArm(-7);
		sleep(100);
		setArm(20);
	}
	//else
	//{
	//	while (gSensor[armPoti].value < 1700) sleep(10);
	//	writeDebugStreamLine("Braking %d", nPgmTime);
	//	setArm(15);
	//}
	while (gSensor[armPoti].value < gArmTarget) sleep(10);
	setArm(15);
	if (gNumCones >= 2) while (!gLiftAsyncDone) sleep(10);
	writeDebugStreamLine("Raised %d %d", nPgmTime, gSensor[armPoti].value);
	if (gNumCones < 3)
	{
		sleep(300);
	}
	else
	{
		setLift(-127);
		while (gSensor[liftPoti].value > LIFT_BOTTOM + gStackDownPos[gNumCones]) sleep(10);
		setLift(gStackHoldPower[gNumCones]);
		if (gNumCones == 3) sleep(150);
		writeDebugStreamLine("Settled %d", nPgmTime);
	}
	if (gNumCones == 10)
	{
		gNumCones = 11
		setLift(-15);
		sleep(500);
		gClawState = clawClosed;
	}
	else
	{
		setClaw(CLAW_OPEN_POWER);
		time = nPgmTime;
		while (gSensor[clawPoti].value < CLAW_OPEN && nPgmTime - time < CLAW_TIMEOUT) sleep(10);
		writeDebugStreamLine("Released %d", nPgmTime);
		setClaw(CLAW_OPEN_HOLD_POWER);
		if (gNumCones < 3) sleep(200); // 300
		else
		{
			setLift(127);
			while (gSensor[liftPoti].value < LIFT_BOTTOM + gStackBackPos[gNumCones]) sleep(10);
			setLift(0);
		}
		++gNumCones;
		gArmTarget = gArmPositions[gArmPosition = 0];
		setArm(-127);
		while (gSensor[armPoti].value > 1800) sleep(10);
		gLiftTarget = LIFT_BOTTOM;
		gLiftAsyncDone = false;
		setLift(-127);
		startTask(liftDownAsync);
		while (gSensor[armPoti].value > gArmTarget + 400) sleep(10);
		if (gNumCones <= 3) sleep(300);
		setArm(-15);
		while (!gLiftAsyncDone) sleep(10);
		setLift(-10);
		writeDebugStreamLine("Done %d %d", nPgmTime, gMaxLiftHeight);
		stopTask(trackLift);
		gClawState = clawOpened;
	}
	gLiftState = liftHold;
	gArmState = armHold;
}

void stack()
{
	gLiftState = liftManaged;
	gArmState = armManaged;
	gClawState = clawManaged;
	startTask(trackLift);
	gArmTarget = gArmPositions[gArmPosition = 0];
	setArm(-127);
	unsigned long time = nPgmTime;
	while (gSensor[armPoti].value > gArmTarget && nPgmTime - time < 1000) sleep(10);
	setArm(-15);
	stackInternal();
}

task stackAsync()
{
	gMacros[stackAsync] = true;
	stack();
	gMacros[stackAsync] = false;
}

void stackFromLoader()
{
	gArmState = armManaged;
	gClawState = clawManaged;

	sPID pid;
	pidInit(pid, 0.2, 0, 0.001, -1, -1, 5, 25);

	setClaw(CLAW_OPEN_HOLD_POWER);
	gArmTarget = 1950;
	if (gSensor[armPoti].value > gArmTarget)
	{
		setArm(-60);
		while (gSensor[armPoti].value > gArmTarget + 40) sleep(10);
	}
	else
	{
		setArm(60);
		while (gSensor[armPoti].value < gArmTarget - 40) sleep(10);
	}
	gArmPIDInUse = &pid;
	startTask(armPID);
	writeDebugStreamLine("Arm at horizontal %d %d", nPgmTime, gSensor[armPoti].value);
	sleep(20000);
	//stackInternal();

	stopTask(armPID);
	gArmPIDInUse = &gArmPID;
	pidReset(gArmPID);
	gArmState = armPlainPID;
}

task stackFromLoaderAsync()
{
	gMacros[stackFromLoaderAsync] = true;
	stackFromLoader();
	gMacros[stackFromLoaderAsync] = false;
}

#define OFFSET_20_ZONE_P1 700
#define OFFSET_20_ZONE_P2 850

void alignAndScore20()
{
	//TODO: Raise lift and arm above stack
	while (gMotor[driveL1].power > 0 || gMotor[driveR1].power > 0)
	{
		setDrive(gSensor[leftLine].value ? -10 : 50, gSensor[rightLine].value ? -10 : 50);
		sleep(10);
	}
	sleep(100);
	setDrive(127, 127);
	int initial = gSensor[driveEncL].value;
	while (gSensor[driveEncL].value < initial + OFFSET_20_ZONE_P1) sleep(10);
	gMobileState = mobileManaged;
	setMobile(MOBILE_DOWN_POWER);
	while (gSensor[driveEncL].value < initial + OFFSET_20_ZONE_P2)
	{
		if (gSensor[mobilePoti].value < MOBILE_20) setMobile(12);
		sleep(10);
	}
	setDrive(-10, -10);
	while (gSensor[mobilePoti].value >= MOBILE_20) sleep(10);
	setMobile(12);
	sleep(200);
	setDrive(-127, -127);
	setMobile(MOBILE_DOWN_POWER);
	while (gSensor[driveEncL].value > initial)
	{
		if (gSensor[mobilePoti].value <= gMobileTarget) setMobile(MOBILE_DOWN_HOLD_POWER);
		sleep(10);
	}
	setDrive(0, 0);
	while (gSensor[mobilePoti].value > gMobileTarget) sleep(10);
	setMobile(gMobileHoldPower = MOBILE_DOWN_HOLD_POWER);
	gMobileState = mobileHold;
}

task alignAndScore20Async()
{
	gMacros[alignAndScore20Async] = true;
	alignAndScore20();
	gMacros[alignAndScore20Async] = false;
}

void handleMacros()
{
	if (RISING(BTN_MACRO_SCAN))
	{
		//startTask(scanStackAsync);
		gNumCones = 0;
	}
	/*if (RISING(BTN_MACRO_20))
	{
		if (gMacros[alignAndScore20Async])
		{
			stopTask(alignAndScore20Async);
			gMotors[alignAndScore20Async] = false;
		}
		else startTask(alignAndScore20Async);
	}*/
	if (RISING(BTN_MACRO_STACK) && gNumCones < 11)
	{
		if (gMacros[stackAsync])
		{
			stopTask(stackAsync);
			gMacros[stackAsync] = false;
			writeDebugStreamLine("Stack cancelled");
		}
		else
		{
			startTask(stackAsync);
			writeDebugStreamLine("Stacking");
			playSound(soundUpwardTones);
		}
	}
	if (RISING(BTN_MACRO_LOADER))
	{
		if (gMacros[stackFromLoaderAsync])
		{
			stopTask(stackFromLoaderAsync);
			gMacros[stackFromLoaderAsync] = false;
		}
		else startTask(stackFromLoaderAsync);
	}
	//if (RISING(JOY_ADJUST))
	//{
	//	if (gJoy[JOY_ADJUST].cur > 0 && gNumCones < 11) ++gNumCones;
	//	else if (gJoy[JOY_ADJUST].cur < 0 && gNumCones > 0) --gNumCones;
	//}
	if (RISING(BTN_MACRO_ADD) && gNumCones < 11) ++gNumCones;
	if (RISING(BTN_MACRO_SUB) && gNumCones > 0) --gNumCones;
}


/* LCD */

void handleLcd()
{
	string line;

	sprintf(line, "%4d %4d %2d", gSensor[driveEncL].value, gSensor[driveEncR].value, gNumCones);
	clearLCDLine(0);
	displayLCDString(0, 0, line);

	velocityCheck(driveEncL);
	velocityCheck(driveEncR);

	sprintf(line, "%2.1f %2.1f", gSensor[driveEncL].velocity, gSensor[driveEncR].velocity);
	clearLCDLine(1);
	displayLCDString(1, 0, line);
}

// This function gets called 2 seconds after power on of the cortex and is the first bit of code that is run
void startup()
{
	clearDebugStream();

	// Setup and initilize the necessary libraries
	setupMotors();
	setupSensors();
	setupJoysticks();

	setupDgtIn(leftLine, 0, 150);
	setupDgtIn(rightLine, 0, 150);
	setupDgtIn(armSonic, 20, 200);

	velocityClear(driveEncL);
	velocityClear(driveEncR);

	gJoy[JOY_TURN].deadzone = DZ_TURN;
	gJoy[JOY_THROTTLE].deadzone = DZ_THROTTLE;
	gJoy[JOY_LIFT].deadzone = DZ_LIFT;
	gJoy[JOY_ARM].deadzone = DZ_ARM;

	pidInit(gArmPID, 0.2, 0.001, 0.0, 50, 150, 5, 127);
}

// This function gets called every 25ms during disabled (DO NOT PUT BLOCKING CODE IN HERE)
void disabled()
{
	handleLcd();
}

// This task gets started at the begining of the autonomous period
task autonomous()
{
	startSensors(); // Initilize the sensors
}

// This task gets started at the beginning of the usercontrol period
task usercontrol()
{
	startSensors(); // Initilize the sensors
	initCycle(gMainCycle, 10);

	while (true)
	{
		updateSensorInputs();
		updateJoysticks();

		handleDrive();
		handleLift();
		handleArm();
		handleClaw();
		handleMobile();
		handleMacros();

		handleLcd();

		updateSensorOutputs();
		updateMotors();
		endCycle(gMainCycle);
	}
}
